# Incident Response Playbook: API Vulnerability Exploitation

## Scenario 22 - API Security Attack (OWASP API Top 10)

### Severity: CRITICAL
### MITRE ATT&CK: T1190 (Exploit Public-Facing Application), T1059 (Command and Scripting Interpreter)

---

## 1. Detection
- [ ] Suricata alert: Sequential API endpoint enumeration (IDOR pattern)
- [ ] Suricata alert: JWT algorithm manipulation in Authorization header
- [ ] Wazuh alert: Brute-force login attempts against /api/auth/login
- [ ] Wazuh alert: Non-admin user accessing /api/admin/ endpoints
- [ ] Wazuh alert: SQL injection patterns in /api/data query parameters
- [ ] Wazuh alert: Mass assignment -- role escalation in registration
- [ ] Application logs: Excessive 401/403 responses from single source IP
- [ ] Application logs: SQL error messages returned in API responses

## 2. Triage (First 15 minutes)
- [ ] Confirm the alert is a true positive (not a penetration test or scanner)
- [ ] Identify source IP address and correlate across all API endpoints
- [ ] Determine which OWASP API Top 10 categories are being exploited
- [ ] Check if authentication was bypassed (look for JWT algorithm confusion)
- [ ] Assess scope: which user accounts and data were accessed
- [ ] Check for mass-assigned admin accounts (newly created users with role=admin)
- [ ] Review /api/data query parameters for SQL injection payloads
- [ ] Determine if data exfiltration occurred (check response sizes)

## 3. Containment (First 30 minutes)

### 3a. Immediate Actions
- [ ] **Block attacker IP** at WAF/firewall level
- [ ] **Revoke all API keys** that may have been exposed
- [ ] **Disable accounts** created via mass assignment with elevated roles
- [ ] **Enforce rate limiting** on all API authentication endpoints
- [ ] **Rotate JWT signing secret** to invalidate all existing tokens

### 3b. Containment Commands
```bash
# Block attacker IP (iptables)
iptables -A INPUT -s <ATTACKER_IP> -j DROP

# Block at Suricata (drop rule)
# Add to local.rules:
# drop http <ATTACKER_IP> any -> $API_SERVERS any (msg:"Block API attacker"; sid:9999999;)

# Check for active sessions from attacker
netstat -an | grep <ATTACKER_IP>

# Disable mass-assigned admin accounts (SQLite)
sqlite3 vuln_api.db "UPDATE users SET role='disabled' WHERE username LIKE 'attacker_%';"

# Revoke exposed API keys
sqlite3 vuln_api.db "UPDATE api_keys SET is_active=0 WHERE key_value IN ('compromised_key_1','compromised_key_2');"

# Rotate JWT secret (requires application restart)
export JWT_SECRET=$(openssl rand -hex 32)
```

### 3c. Rate Limiting (nginx)
```nginx
limit_req_zone $binary_remote_addr zone=api_login:10m rate=5r/m;
limit_req_zone $binary_remote_addr zone=api_register:10m rate=3r/m;

location /api/auth/login {
    limit_req zone=api_login burst=3 nodelay;
    limit_req_status 429;
}
```

## 4. Eradication

### 4a. Fix Broken Authentication (API2)
- [ ] Use strong JWT secret (256+ bits of entropy)
- [ ] Restrict JWT algorithms: `algorithms=["HS256"]` only
- [ ] Implement token expiration and refresh token rotation
- [ ] Remove detailed error messages (username exists, password wrong)

### 4b. Fix IDOR (API1)
```python
# VULNERABLE (before)
user = db.execute("SELECT * FROM users WHERE id=?", (user_id,)).fetchone()

# SECURE (after) -- verify ownership
user = db.execute("SELECT * FROM users WHERE id=?", (user_id,)).fetchone()
if user["id"] != current_user["user_id"] and current_user["role"] != "admin":
    return jsonify({"error": "Forbidden"}), 403
```

### 4c. Fix Mass Assignment (API6)
```python
# VULNERABLE (before) -- accepts role from request
role = data.get("role", "user")

# SECURE (after) -- whitelist allowed fields
ALLOWED_REGISTER_FIELDS = {"username", "password", "email", "full_name"}
data = {k: v for k, v in request.json.items() if k in ALLOWED_REGISTER_FIELDS}
role = "user"  # Always set server-side
```

### 4d. Fix SQL Injection (API8)
```python
# VULNERABLE (before)
sql = f"SELECT * FROM {table} WHERE account_number LIKE '%{query_param}%'"

# SECURE (after) -- parameterized query with table whitelist
ALLOWED_TABLES = {"financial_data", "audit_log"}
if table not in ALLOWED_TABLES:
    return jsonify({"error": "Invalid table"}), 400
sql = "SELECT * FROM financial_data WHERE account_number LIKE ?"
results = db.execute(sql, (f"%{query_param}%",)).fetchall()
```

### 4e. Fix Excessive Data Exposure (API3)
- [ ] Create response DTOs that exclude sensitive fields (SSN, salary, API keys)
- [ ] Implement field-level access control
- [ ] Never return internal identifiers or credentials in API responses

### 4f. Fix Broken Function Level Auth (API5)
```python
# VULNERABLE (before) -- only checks authentication
current = get_current_user()
if not current:
    return jsonify({"error": "Auth required"}), 401

# SECURE (after) -- checks authorization
current = get_current_user()
if not current:
    return jsonify({"error": "Auth required"}), 401
if current["role"] != "admin":
    return jsonify({"error": "Admin access required"}), 403
```

## 5. Recovery
- [ ] Rotate all database credentials
- [ ] Re-deploy patched API with all fixes applied
- [ ] Force password reset for all affected user accounts
- [ ] Issue new API keys to legitimate users
- [ ] Gradually remove IP blocks after monitoring period (72 hours)
- [ ] Run OWASP ZAP / Burp Suite scan against patched API to confirm fixes
- [ ] Verify all endpoints enforce proper authorization

## 6. Lessons Learned
- [ ] Document full timeline of attack and response
- [ ] Identify gaps in detection (time to detect, missed attack vectors)
- [ ] Update WAF rules for API-specific attack patterns
- [ ] Schedule developer training on OWASP API Security Top 10
- [ ] Implement API gateway with built-in rate limiting and auth
- [ ] Add API security testing to CI/CD pipeline (DAST)

## 7. Prevention Measures
- Implement an API gateway (Kong, AWS API Gateway) with rate limiting
- Use strong JWT secrets and restrict accepted algorithms
- Enforce object-level authorization checks on every endpoint
- Use response DTOs / serializers to control exposed fields
- Whitelist allowed fields for mass assignment
- Use parameterized queries exclusively -- never interpolate user input
- Implement comprehensive API logging and monitoring
- Regular API security audits using OWASP API Security Testing Guide
- Schema validation for all request payloads (OpenAPI/JSON Schema)
- Implement API versioning to manage deprecation of insecure endpoints
