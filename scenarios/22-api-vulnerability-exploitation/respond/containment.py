#!/usr/bin/env python3
"""
Scenario 22: Automated containment response for API vulnerability exploitation.

Actions:
1. Revoke compromised API keys
2. Enforce rate limiting rules
3. Block attacker IP via firewall/WAF
4. Disable mass-assigned admin accounts
5. Generate Suricata drop rules
6. Preserve evidence
"""

import json
import os
import sys
from datetime import datetime

from colorama import Fore, Style, init

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))

from wcace_lib.wazuh_api import WazuhAPI
from wcace_lib.constants import ATTACKER_IP, API_SERVER_IP

init(autoreset=True)


def revoke_api_keys(compromised_keys: list[str]) -> list[str]:
    """Revoke compromised API keys."""
    actions = []
    for key in compromised_keys:
        # In production this would call the API key management system
        actions.append(f"REVOKED API key: {key}")
    return actions


def enforce_rate_limiting() -> list[str]:
    """Generate rate limiting configuration."""
    actions = []

    # Nginx rate limiting config
    nginx_config = """
# Rate limiting for API endpoints
limit_req_zone $binary_remote_addr zone=api_login:10m rate=5r/m;
limit_req_zone $binary_remote_addr zone=api_general:10m rate=30r/m;
limit_req_zone $binary_remote_addr zone=api_register:10m rate=3r/m;

server {
    location /api/auth/login {
        limit_req zone=api_login burst=3 nodelay;
        limit_req_status 429;
        proxy_pass http://api_backend;
    }
    location /api/auth/register {
        limit_req zone=api_register burst=2 nodelay;
        limit_req_status 429;
        proxy_pass http://api_backend;
    }
    location /api/ {
        limit_req zone=api_general burst=10 nodelay;
        limit_req_status 429;
        proxy_pass http://api_backend;
    }
}
"""
    actions.append("Generated nginx rate limiting configuration")
    actions.append(f"Config:\n{nginx_config.strip()}")

    return actions


def block_attacker_ip(ip: str) -> list[str]:
    """Generate firewall and WAF block rules."""
    actions = [
        f"iptables -A INPUT -s {ip} -j DROP",
        f"iptables -A INPUT -s {ip} -p tcp --dport 8080 -j DROP",
        f"ip route add blackhole {ip}/32",
    ]
    return actions


def disable_unauthorized_accounts() -> list[str]:
    """Disable accounts created via mass assignment with elevated privileges."""
    actions = [
        "SQL: UPDATE users SET role='disabled' WHERE username LIKE 'attacker_%' AND role='admin'",
        "SQL: UPDATE users SET password_hash='LOCKED' WHERE username LIKE 'attacker_%'",
        "SQL: INSERT INTO audit_log (action, details) VALUES ('containment', "
        "'Disabled mass-assigned admin accounts')",
    ]
    return actions


def generate_suricata_drop_rules(ip: str) -> list[str]:
    """Generate Suricata drop rules for the attacker."""
    rules = [
        f'drop http {ip} any -> $API_SERVERS any '
        f'(msg:"WCACE: Block API attacker {ip}"; sid:9229001; rev:1;)',
        f'drop tcp {ip} any -> {API_SERVER_IP} 8080 '
        f'(msg:"WCACE: Block API attacker {ip} all traffic"; sid:9229002; rev:1;)',
    ]
    return rules


def preserve_evidence(attacker_ip: str, logs_dir: str) -> str:
    """Create evidence package for the incident."""
    evidence = {
        "incident_id": f"INC-API-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
        "type": "API Vulnerability Exploitation",
        "classification": "OWASP API Security Top 10",
        "attacker_ip": attacker_ip,
        "target": f"{API_SERVER_IP}:8080",
        "timestamp": datetime.now().isoformat(),
        "attack_vectors": [
            "API1 - Broken Object Level Authorization (IDOR)",
            "API2 - Broken Authentication (JWT bypass, brute force)",
            "API3 - Excessive Data Exposure",
            "API4 - Lack of Resources & Rate Limiting",
            "API5 - Broken Function Level Authorization",
            "API6 - Mass Assignment",
            "API8 - Injection (SQL Injection)",
        ],
        "containment_actions": [
            f"Firewall rule: iptables -A INPUT -s {attacker_ip} -j DROP",
            "API keys revoked for compromised accounts",
            "Rate limiting enforced on all API endpoints",
            "Mass-assigned admin accounts disabled",
            "Suricata drop rules deployed",
        ],
        "mitre_attack": ["T1190", "T1059", "T1078"],
        "evidence_files": [],
    }

    # List available log files
    if os.path.exists(logs_dir):
        for f in os.listdir(logs_dir):
            evidence["evidence_files"].append(os.path.join(logs_dir, f))

    evidence_file = os.path.join(logs_dir, "api_incident_evidence.json")
    os.makedirs(logs_dir, exist_ok=True)
    with open(evidence_file, "w") as f:
        json.dump(evidence, f, indent=2)

    return evidence_file


def main():
    print(f"""
{Fore.RED}{'='*62}
  WCACE Scenario 22: API Attack Containment Response
{'='*62}{Style.RESET_ALL}
""")

    attacker_ip = ATTACKER_IP
    logs_dir = os.path.join(os.path.dirname(__file__), "..", "logs", "sample_logs")

    # Step 1: Revoke compromised API keys
    print(f"{Fore.YELLOW}[1/6] Revoking compromised API keys...{Style.RESET_ALL}")
    compromised_keys = [
        "ak_admin_superkey_001",
        "ak_john_key_002",
        "ak_svc_key_005",
    ]
    key_actions = revoke_api_keys(compromised_keys)
    for action in key_actions:
        print(f"  -> {action}")

    # Step 2: Enforce rate limiting
    print(f"\n{Fore.YELLOW}[2/6] Enforcing rate limiting...{Style.RESET_ALL}")
    rate_actions = enforce_rate_limiting()
    print(f"  -> {rate_actions[0]}")

    # Step 3: Block attacker IP
    print(f"\n{Fore.YELLOW}[3/6] Blocking attacker IP...{Style.RESET_ALL}")
    fw_rules = block_attacker_ip(attacker_ip)
    for rule in fw_rules:
        print(f"  -> {rule}")

    # Step 4: Disable unauthorized accounts
    print(f"\n{Fore.YELLOW}[4/6] Disabling mass-assigned admin accounts...{Style.RESET_ALL}")
    acct_actions = disable_unauthorized_accounts()
    for action in acct_actions:
        print(f"  -> {action}")

    # Step 5: Generate Suricata drop rules
    print(f"\n{Fore.YELLOW}[5/6] Generating Suricata drop rules...{Style.RESET_ALL}")
    suricata_rules = generate_suricata_drop_rules(attacker_ip)
    for rule in suricata_rules:
        print(f"  -> {rule}")

    # Step 6: Try Wazuh active response
    print(f"\n{Fore.YELLOW}[6/6] Attempting Wazuh active response...{Style.RESET_ALL}")
    try:
        api = WazuhAPI()
        if api.check_connection():
            print(f"  [+] Wazuh connected - active response would block {attacker_ip}")
        else:
            print(f"  [*] Wazuh not available - manual block required")
    except Exception:
        print(f"  [*] Wazuh not available - manual block required")

    # Preserve evidence
    print(f"\n{Fore.YELLOW}[*] Preserving evidence...{Style.RESET_ALL}")
    evidence_path = preserve_evidence(attacker_ip, logs_dir)
    print(f"  -> Evidence saved to: {evidence_path}")

    # Summary
    print(f"\n{Fore.GREEN}{'='*62}")
    print(f"  Containment Actions Summary")
    print(f"{'='*62}{Style.RESET_ALL}")
    print(f"  Attacker IP:        {attacker_ip}")
    print(f"  API Keys Revoked:   {len(compromised_keys)}")
    print(f"  Rate Limiting:      Enforced (nginx config generated)")
    print(f"  Firewall Rules:     {len(fw_rules)} rules generated")
    print(f"  Accounts Disabled:  Mass-assigned admin accounts locked")
    print(f"  Suricata Rules:     {len(suricata_rules)} drop rules generated")
    print(f"  Evidence:           {evidence_path}")
    print(f"\n  Next steps: Review respond/playbook.md for full IR procedure")


if __name__ == "__main__":
    main()
