#!/usr/bin/env python3
"""
Scenario 22: Vulnerable Flask REST API with OWASP API Top 10 flaws.

WARNING: This application is INTENTIONALLY VULNERABLE for educational purposes.
DO NOT deploy this in any production or internet-facing environment.

Vulnerabilities included:
- API1: Broken Object Level Authorization (IDOR)
- API2: Broken Authentication (weak JWT, algorithm bypass)
- API3: Excessive Data Exposure
- API4: Lack of Resources & Rate Limiting
- API5: Broken Function Level Authorization
- API6: Mass Assignment
- API8: Injection (SQL injection in query params)
"""

import hashlib
import os
import sqlite3
import time

import jwt
from flask import Flask, request, jsonify, g

app = Flask(__name__)

DATABASE = os.path.join(os.path.dirname(__file__), "vuln_api.db")

# VULNERABLE: Weak JWT secret (easily brute-forced or guessable)
JWT_SECRET = "secret123"
# VULNERABLE: No algorithm restriction
JWT_ALGORITHM = "HS256"


# ===========================================================
# Database helpers
# ===========================================================

def get_db():
    """Get database connection (stored in Flask's g object)."""
    if "db" not in g:
        g.db = sqlite3.connect(DATABASE)
        g.db.row_factory = sqlite3.Row
    return g.db


@app.teardown_appcontext
def close_db(exception):
    db = g.pop("db", None)
    if db is not None:
        db.close()


def init_db():
    """Initialize database with sample data."""
    db = sqlite3.connect(DATABASE)
    db.executescript("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT NOT NULL UNIQUE,
            password_hash TEXT NOT NULL,
            email TEXT,
            role TEXT DEFAULT 'user',
            full_name TEXT,
            ssn TEXT,
            salary REAL,
            api_key TEXT
        );

        CREATE TABLE IF NOT EXISTS financial_data (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            account_number TEXT,
            balance REAL,
            card_number TEXT,
            card_cvv TEXT,
            transactions_json TEXT,
            FOREIGN KEY (user_id) REFERENCES users(id)
        );

        CREATE TABLE IF NOT EXISTS api_keys (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            key_value TEXT NOT NULL,
            user_id INTEGER,
            scope TEXT DEFAULT 'read',
            is_active INTEGER DEFAULT 1,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id)
        );

        CREATE TABLE IF NOT EXISTS audit_log (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            user_id INTEGER,
            action TEXT,
            details TEXT,
            ip_address TEXT
        );
    """)

    # Sample users (passwords are md5 hashed for demo -- intentionally weak)
    users = [
        (1, "admin", hashlib.md5(b"admin123!").hexdigest(),
         "admin@acmecorp.local", "admin", "System Administrator",
         "123-45-6789", 150000.00, "ak_admin_superkey_001"),
        (2, "john.doe", hashlib.md5(b"password123").hexdigest(),
         "john@acmecorp.local", "user", "John Doe",
         "234-56-7890", 75000.00, "ak_john_key_002"),
        (3, "jane.smith", hashlib.md5(b"letmein").hexdigest(),
         "jane@acmecorp.local", "user", "Jane Smith",
         "345-67-8901", 82000.00, "ak_jane_key_003"),
        (4, "bob.wilson", hashlib.md5(b"qwerty2024").hexdigest(),
         "bob@acmecorp.local", "manager", "Bob Wilson",
         "456-78-9012", 95000.00, "ak_bob_key_004"),
        (5, "svc_api", hashlib.md5(b"ApiS3rv1ce!").hexdigest(),
         "svc@acmecorp.local", "service", "API Service Account",
         "000-00-0000", 0.00, "ak_svc_key_005"),
    ]

    for u in users:
        try:
            db.execute(
                "INSERT INTO users (id, username, password_hash, email, role, "
                "full_name, ssn, salary, api_key) VALUES (?,?,?,?,?,?,?,?,?)", u
            )
        except sqlite3.IntegrityError:
            pass

    # Financial data
    fin_data = [
        (1, 2, "ACCT-10001234", 15420.50, "4111-1111-1111-1234", "321",
         '[{"date":"2025-01-15","amount":-150.00,"desc":"Monthly subscription"}]'),
        (2, 3, "ACCT-10005678", 32100.75, "5500-0000-0000-5678", "654",
         '[{"date":"2025-01-20","amount":-299.99,"desc":"Annual plan"}]'),
        (3, 4, "ACCT-10009012", 125750.00, "3782-8224-6310-9012", "987",
         '[{"date":"2025-02-01","amount":-49999.99,"desc":"Enterprise purchase"}]'),
    ]

    for fd in fin_data:
        try:
            db.execute(
                "INSERT INTO financial_data (id, user_id, account_number, balance, "
                "card_number, card_cvv, transactions_json) VALUES (?,?,?,?,?,?,?)", fd
            )
        except sqlite3.IntegrityError:
            pass

    # API keys
    api_keys = [
        (1, "ak_admin_superkey_001", 1, "read,write,admin", 1),
        (2, "ak_john_key_002", 2, "read", 1),
        (3, "ak_jane_key_003", 3, "read", 1),
        (4, "ak_bob_key_004", 4, "read,write", 1),
        (5, "ak_svc_key_005", 5, "read,write,admin", 1),
    ]

    for ak in api_keys:
        try:
            db.execute(
                "INSERT INTO api_keys (id, key_value, user_id, scope, is_active) "
                "VALUES (?,?,?,?,?)", ak
            )
        except sqlite3.IntegrityError:
            pass

    db.commit()
    db.close()


# ===========================================================
# JWT Helpers
# ===========================================================

def create_token(user_id: int, username: str, role: str) -> str:
    """Create a JWT token. VULNERABLE: weak secret."""
    payload = {
        "user_id": user_id,
        "username": username,
        "role": role,
        "iat": int(time.time()),
        "exp": int(time.time()) + 3600,
    }
    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)


def verify_token(token: str) -> dict | None:
    """Verify JWT token. VULNERABLE: accepts 'none' algorithm."""
    if not token:
        return None
    try:
        # VULNERABLE: algorithms parameter not restricted
        # Attacker can use {"alg":"none"} to bypass signature verification
        decoded = jwt.decode(
            token, JWT_SECRET,
            algorithms=["HS256", "HS384", "HS512", "none"],
            options={"verify_exp": False},
        )
        return decoded
    except jwt.exceptions.PyJWTError:
        return None


def get_current_user():
    """Extract user from Authorization header."""
    auth_header = request.headers.get("Authorization", "")
    if auth_header.startswith("Bearer "):
        token = auth_header[7:]
        return verify_token(token)
    return None


# ===========================================================
# API Endpoints
# ===========================================================

@app.route("/api")
def api_index():
    return jsonify({
        "app": "WCACE Vulnerable REST API",
        "version": "1.0.0",
        "warning": "INTENTIONALLY VULNERABLE - Educational use only",
        "endpoints": [
            "POST /api/auth/login",
            "POST /api/auth/register",
            "GET  /api/users/<id>",
            "PUT  /api/users/<id>",
            "GET  /api/admin/users",
            "GET  /api/data",
            "GET  /api/keys",
        ],
    })


# --- Authentication Endpoints ---

@app.route("/api/auth/login", methods=["POST"])
def login():
    """
    Login endpoint.
    VULNERABLE: No rate limiting, weak password hashing (MD5),
    detailed error messages.
    """
    data = request.get_json(silent=True) or {}
    username = data.get("username", "")
    password = data.get("password", "")

    if not username or not password:
        return jsonify({"error": "Username and password required"}), 400

    password_hash = hashlib.md5(password.encode()).hexdigest()

    db = get_db()
    user = db.execute(
        "SELECT * FROM users WHERE username=? AND password_hash=?",
        (username, password_hash)
    ).fetchone()

    if user:
        token = create_token(user["id"], user["username"], user["role"])
        # VULNERABLE: Excessive data exposure -- returns too much user info
        return jsonify({
            "status": "success",
            "token": token,
            "user": {
                "id": user["id"],
                "username": user["username"],
                "email": user["email"],
                "role": user["role"],
                "full_name": user["full_name"],
                "ssn": user["ssn"],           # Should NOT be returned
                "salary": user["salary"],     # Should NOT be returned
                "api_key": user["api_key"],   # Should NOT be returned
            }
        })

    # VULNERABLE: Reveals whether username exists
    existing = db.execute(
        "SELECT id FROM users WHERE username=?", (username,)
    ).fetchone()
    if existing:
        return jsonify({"error": "Invalid password", "username_exists": True}), 401
    return jsonify({"error": "User not found", "username_exists": False}), 401


@app.route("/api/auth/register", methods=["POST"])
def register():
    """
    Registration endpoint.
    VULNERABLE: Mass assignment -- accepts 'role' from user input.
    No input validation, no rate limiting.
    """
    data = request.get_json(silent=True) or {}
    username = data.get("username", "")
    password = data.get("password", "")
    email = data.get("email", "")
    full_name = data.get("full_name", "")

    if not username or not password:
        return jsonify({"error": "Username and password required"}), 400

    # VULNERABLE: Mass assignment -- attacker can set role to 'admin'
    role = data.get("role", "user")

    password_hash = hashlib.md5(password.encode()).hexdigest()
    api_key = f"ak_{username}_key_{int(time.time())}"

    db = get_db()
    try:
        cursor = db.execute(
            "INSERT INTO users (username, password_hash, email, role, full_name, "
            "ssn, salary, api_key) VALUES (?, ?, ?, ?, ?, '', 0, ?)",
            (username, password_hash, email, role, full_name, api_key)
        )
        db.commit()
        user_id = cursor.lastrowid
        token = create_token(user_id, username, role)

        return jsonify({
            "status": "success",
            "message": f"User {username} registered with role: {role}",
            "user_id": user_id,
            "token": token,
            "api_key": api_key,
        }), 201
    except sqlite3.IntegrityError:
        return jsonify({"error": f"Username '{username}' already exists"}), 409


# --- User Data Endpoints ---

@app.route("/api/users/<int:user_id>", methods=["GET"])
def get_user(user_id):
    """
    Get user profile.
    VULNERABLE: Broken Object Level Authorization (BOLA/IDOR).
    Any authenticated user can access any other user's data.
    Also: Excessive data exposure (returns SSN, salary).
    """
    current = get_current_user()
    if not current:
        return jsonify({"error": "Authentication required"}), 401

    # VULNERABLE: No check that current user can access this user_id
    db = get_db()
    user = db.execute("SELECT * FROM users WHERE id=?", (user_id,)).fetchone()

    if not user:
        return jsonify({"error": "User not found"}), 404

    # VULNERABLE: Returns all fields including sensitive ones
    return jsonify({
        "user": {
            "id": user["id"],
            "username": user["username"],
            "email": user["email"],
            "role": user["role"],
            "full_name": user["full_name"],
            "ssn": user["ssn"],
            "salary": user["salary"],
            "api_key": user["api_key"],
        }
    })


@app.route("/api/users/<int:user_id>", methods=["PUT"])
def update_user(user_id):
    """
    Update user profile.
    VULNERABLE: IDOR + mass assignment (can change role).
    """
    current = get_current_user()
    if not current:
        return jsonify({"error": "Authentication required"}), 401

    # VULNERABLE: No ownership check
    data = request.get_json(silent=True) or {}
    db = get_db()

    # VULNERABLE: Allows updating any field including role
    set_clauses = []
    values = []
    for field in ["email", "full_name", "role", "salary"]:
        if field in data:
            set_clauses.append(f"{field}=?")
            values.append(data[field])

    if not set_clauses:
        return jsonify({"error": "No fields to update"}), 400

    values.append(user_id)
    query = f"UPDATE users SET {', '.join(set_clauses)} WHERE id=?"
    db.execute(query, values)
    db.commit()

    return jsonify({"status": "success", "message": f"User {user_id} updated"})


# --- Admin Endpoints ---

@app.route("/api/admin/users", methods=["GET"])
def admin_list_users():
    """
    Admin endpoint to list all users.
    VULNERABLE: Broken Function Level Authorization.
    Checks for auth but does NOT verify admin role.
    """
    current = get_current_user()
    if not current:
        return jsonify({"error": "Authentication required"}), 401

    # VULNERABLE: Should check current["role"] == "admin"
    # Any authenticated user can access this admin endpoint
    db = get_db()
    users = db.execute("SELECT * FROM users").fetchall()

    return jsonify({
        "users": [
            {
                "id": u["id"],
                "username": u["username"],
                "email": u["email"],
                "role": u["role"],
                "full_name": u["full_name"],
                "ssn": u["ssn"],
                "salary": u["salary"],
                "api_key": u["api_key"],
            }
            for u in users
        ],
        "total": len(users),
    })


# --- Data Query Endpoint ---

@app.route("/api/data", methods=["GET"])
def query_data():
    """
    Data query endpoint.
    VULNERABLE: SQL injection in query parameter.
    No input sanitization, direct string interpolation.
    """
    current = get_current_user()
    if not current:
        return jsonify({"error": "Authentication required"}), 401

    query_param = request.args.get("query", "")
    table = request.args.get("table", "financial_data")

    if not query_param:
        return jsonify({"error": "query parameter required"}), 400

    # VULNERABLE: Direct string interpolation -- classic SQL injection
    sql = f"SELECT * FROM {table} WHERE account_number LIKE '%{query_param}%'"

    db = get_db()
    try:
        results = db.execute(sql).fetchall()
        return jsonify({
            "results": [dict(r) for r in results],
            "count": len(results),
            "query": query_param,
        })
    except Exception as e:
        # VULNERABLE: Exposes SQL error details
        return jsonify({"error": str(e), "sql": sql}), 500


# --- API Key Endpoint ---

@app.route("/api/keys", methods=["GET"])
def list_keys():
    """
    List API keys.
    VULNERABLE: Returns all keys, not just the current user's.
    """
    current = get_current_user()
    if not current:
        return jsonify({"error": "Authentication required"}), 401

    # VULNERABLE: No filtering by current user
    db = get_db()
    keys = db.execute("SELECT * FROM api_keys WHERE is_active=1").fetchall()

    return jsonify({
        "keys": [
            {
                "id": k["id"],
                "key_value": k["key_value"],
                "user_id": k["user_id"],
                "scope": k["scope"],
                "created_at": k["created_at"],
            }
            for k in keys
        ]
    })


# ===========================================================
# Health check
# ===========================================================

@app.route("/api/health")
def health():
    return jsonify({"status": "ok", "timestamp": int(time.time())})


# ===========================================================
# Main
# ===========================================================

if __name__ == "__main__":
    init_db()
    print("[*] Vulnerable REST API starting on http://0.0.0.0:8080")
    print("[!] WARNING: This API is intentionally vulnerable!")
    print("[!] Endpoints:")
    print("    POST /api/auth/login")
    print("    POST /api/auth/register")
    print("    GET  /api/users/<id>")
    print("    PUT  /api/users/<id>")
    print("    GET  /api/admin/users")
    print("    GET  /api/data?query=&table=")
    print("    GET  /api/keys")
    app.run(host="0.0.0.0", port=8080, debug=False)
