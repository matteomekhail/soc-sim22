#!/usr/bin/env python3
"""
Scenario 20: Automated containment response for ransomware-via-exploit-kit attacks.

COMBO scenario: Watering Hole (S12) + Ransomware (S08).

Actions:
1. Kill ransomware process and isolate victim host
2. Block watering hole and exploit kit domains
3. Block C2 server communication
4. Preserve encryption key for file recovery
5. Generate Suricata drop rules
6. Attempt file recovery with saved encryption key
7. Preserve evidence
"""

import json
import os
import sys
from datetime import datetime

from colorama import Fore, Style, init

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))

from wcace_lib.wazuh_api import WazuhAPI
from wcace_lib.constants import (
    ATTACKER_IPS, C2_SERVER_IP, C2_DOMAIN, WATERING_HOLE_DOMAIN,
)

init(autoreset=True)

SANDBOX_DIR = "/tmp/wcace-sandbox/ransomware-ek-files"
KEY_FILE_PATH = os.path.join(
    os.path.dirname(__file__), "..", "logs", "sample_logs", "encryption_key.txt"
)

# Domains and IPs to block
MALICIOUS_DOMAINS = [
    WATERING_HOLE_DOMAIN,
    "cdn-assets.newsportal.test",
    C2_DOMAIN,
]
MALICIOUS_IPS = [ATTACKER_IPS[3], C2_SERVER_IP]


def kill_ransomware_process() -> list[str]:
    """Generate commands to kill the ransomware process."""
    return [
        "# Kill the ransomware process",
        "taskkill /IM svchost_patch.exe /F",
        "pkill -f svchost_patch  # Linux equivalent",
        "",
        "# Kill any child processes",
        "pgrep -P $(pgrep svchost_patch) | xargs kill -9",
        "",
        "# Verify process is terminated",
        "ps aux | grep svchost_patch",
    ]


def isolate_host() -> list[str]:
    """Generate commands to isolate the victim host from the network."""
    return [
        "# Isolate victim host - block all outbound except management",
        "iptables -A OUTPUT -p tcp --dport 443 -j DROP",
        "iptables -A OUTPUT -p tcp --dport 80 -j DROP",
        "# Allow only management subnet",
        "iptables -A INPUT -s 10.0.0.0/24 -j ACCEPT",
        "iptables -A OUTPUT -d 10.0.0.0/24 -j ACCEPT",
        "iptables -A OUTPUT -j DROP",
        "",
        "# Or via Wazuh active response (preferred):",
        "# /var/ossec/active-response/bin/host-deny.sh add <VICTIM_IP>",
    ]


def block_domains_and_ips(domains: list[str], ips: list[str]) -> list[str]:
    """Generate firewall and DNS rules to block malicious infrastructure."""
    rules = ["# DNS sinkhole for watering hole and exploit kit domains"]
    for domain in domains:
        rules.append(f"0.0.0.0  {domain}")
        rules.append(f"0.0.0.0  *.{domain}")

    rules.append("")
    rules.append("# Firewall rules to block malicious IPs")
    for ip in ips:
        rules.append(f"iptables -A INPUT -s {ip} -j DROP")
        rules.append(f"iptables -A OUTPUT -d {ip} -j DROP")

    return rules


def generate_suricata_drop_rules(domains: list[str], ips: list[str]) -> list[str]:
    """Generate Suricata drop rules for containment."""
    rules = []
    base_sid = 9209001

    for i, ip in enumerate(ips):
        rules.append(
            f'drop ip {ip} any -> $HOME_NET any '
            f'(msg:"WCACE S20: Block ransomware-EK attacker {ip}"; '
            f'sid:{base_sid + i}; rev:1;)'
        )

    for i, domain in enumerate(domains):
        rules.append(
            f'drop dns any any -> any 53 '
            f'(msg:"WCACE S20: Block DNS to ransomware/EK domain {domain}"; '
            f'dns.query; content:"{domain}"; nocase; '
            f'sid:{base_sid + len(ips) + i}; rev:1;)'
        )

    return rules


def attempt_file_recovery() -> dict:
    """Attempt to recover encrypted files using the saved encryption key."""
    recovery = {
        "key_found": False,
        "key": "",
        "files_recovered": 0,
        "files_failed": 0,
    }

    if not os.path.exists(KEY_FILE_PATH):
        return recovery

    # Read the encryption key
    with open(KEY_FILE_PATH) as f:
        for line in f:
            if line.startswith("key="):
                recovery["key"] = line.strip().split("=", 1)[1]
                recovery["key_found"] = True
                break

    if not recovery["key_found"] or not os.path.exists(SANDBOX_DIR):
        return recovery

    try:
        from cryptography.fernet import Fernet

        fernet = Fernet(recovery["key"].encode())

        for root, dirs, files in os.walk(SANDBOX_DIR):
            for filename in files:
                if not filename.endswith(".encrypted"):
                    continue

                encrypted_path = os.path.join(root, filename)
                original_path = encrypted_path[:-len(".encrypted")]

                try:
                    with open(encrypted_path, "rb") as f:
                        encrypted_data = f.read()

                    decrypted_data = fernet.decrypt(encrypted_data)

                    with open(original_path, "wb") as f:
                        f.write(decrypted_data)

                    os.remove(encrypted_path)
                    recovery["files_recovered"] += 1

                except Exception:
                    recovery["files_failed"] += 1

    except ImportError:
        pass

    return recovery


def preserve_evidence(ips: list[str], domains: list[str], logs_dir: str) -> str:
    """Create evidence package for the incident."""
    evidence = {
        "incident_id": f"INC-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
        "type": "Ransomware via Exploit Kit (Combo: S12 + S08)",
        "malicious_ips": ips,
        "malicious_domains": domains,
        "watering_hole": WATERING_HOLE_DOMAIN,
        "c2_server": f"{C2_DOMAIN} ({C2_SERVER_IP})",
        "timestamp": datetime.now().isoformat(),
        "mitre_techniques": ["T1189", "T1203", "T1486", "T1573"],
        "attack_chain": [
            "User visited compromised watering hole site (news-portal.test)",
            "Injected script redirected to exploit kit infrastructure",
            "Exploit kit exploited CVE-2021-21224 in Chrome V8 engine",
            "Ransomware payload delivered and executed",
            "Files encrypted with Fernet symmetric encryption",
            "Encryption key exfiltrated to C2 server",
            "Ransom note dropped in affected directories",
        ],
        "containment_actions": [
            "Ransomware process terminated",
            "Victim host isolated from network",
            f"DNS sinkhole applied for {len(domains)} domains",
            f"Firewall rules generated for {len(ips)} IPs",
            "Suricata drop rules generated",
            "File recovery attempted with saved encryption key",
        ],
        "evidence_files": [],
    }

    if os.path.exists(logs_dir):
        for f in os.listdir(logs_dir):
            evidence["evidence_files"].append(os.path.join(logs_dir, f))

    evidence_file = os.path.join(logs_dir, "incident_evidence.json")
    os.makedirs(logs_dir, exist_ok=True)
    with open(evidence_file, "w") as f:
        json.dump(evidence, f, indent=2)

    return evidence_file


def main():
    print(f"""
{Fore.RED}+============================================================+
|  WCACE Scenario 20: Ransomware via Exploit Kit Containment |
|  COMBO: Watering Hole (S12) + Ransomware (S08)             |
+============================================================+{Style.RESET_ALL}
""")

    logs_dir = os.path.join(os.path.dirname(__file__), "..", "logs", "sample_logs")

    # Step 1: Kill ransomware process
    print(f"{Fore.YELLOW}[1/7] Terminating ransomware process...{Style.RESET_ALL}")
    kill_cmds = kill_ransomware_process()
    for cmd in kill_cmds:
        print(f"  {cmd}")

    # Step 2: Isolate victim host
    print(f"\n{Fore.YELLOW}[2/7] Isolating victim host from network...{Style.RESET_ALL}")
    isolate_cmds = isolate_host()
    for cmd in isolate_cmds:
        print(f"  {cmd}")

    # Step 3: Block malicious infrastructure
    print(f"\n{Fore.YELLOW}[3/7] Blocking malicious domains and IPs...{Style.RESET_ALL}")
    block_rules = block_domains_and_ips(MALICIOUS_DOMAINS, MALICIOUS_IPS)
    for rule in block_rules[:8]:
        print(f"  {rule}")
    if len(block_rules) > 8:
        print(f"  ... and {len(block_rules) - 8} more rules")

    # Step 4: Suricata drop rules
    print(f"\n{Fore.YELLOW}[4/7] Generating Suricata drop rules...{Style.RESET_ALL}")
    suricata_rules = generate_suricata_drop_rules(MALICIOUS_DOMAINS, MALICIOUS_IPS)
    for rule in suricata_rules[:3]:
        print(f"  {rule[:80]}...")
    if len(suricata_rules) > 3:
        print(f"  ... and {len(suricata_rules) - 3} more rules")

    # Step 5: Attempt file recovery
    print(f"\n{Fore.YELLOW}[5/7] Attempting file recovery with saved encryption key...{Style.RESET_ALL}")
    recovery = attempt_file_recovery()
    if recovery["key_found"]:
        print(f"  [+] Encryption key found: {recovery['key'][:20]}...")
        if recovery["files_recovered"] > 0:
            print(f"  {Fore.GREEN}[+] Files recovered: {recovery['files_recovered']}{Style.RESET_ALL}")
        if recovery["files_failed"] > 0:
            print(f"  {Fore.RED}[!] Files failed: {recovery['files_failed']}{Style.RESET_ALL}")
        if recovery["files_recovered"] == 0 and recovery["files_failed"] == 0:
            print(f"  [*] No encrypted files found in sandbox (may not have been run)")
    else:
        print(f"  [!] Encryption key not found -- run simulate_attack.py first")
        print(f"  [*] Key would be saved at: {KEY_FILE_PATH}")

    # Step 6: Try Wazuh active response
    print(f"\n{Fore.YELLOW}[6/7] Attempting Wazuh active response...{Style.RESET_ALL}")
    try:
        api = WazuhAPI()
        if api.check_connection():
            print(f"  [+] Wazuh connected - active response would isolate victim host")
            print(f"  [+] Would block {len(MALICIOUS_IPS)} IPs and {len(MALICIOUS_DOMAINS)} domains")
        else:
            print(f"  [*] Wazuh not available - manual containment required")
    except Exception:
        print(f"  [*] Wazuh not available - manual containment required")

    # Step 7: Preserve evidence
    print(f"\n{Fore.YELLOW}[7/7] Preserving evidence...{Style.RESET_ALL}")
    evidence_path = preserve_evidence(MALICIOUS_IPS, MALICIOUS_DOMAINS, logs_dir)
    print(f"  Evidence saved to: {evidence_path}")

    # Summary
    print(f"\n{Fore.GREEN}{'='*62}")
    print(f"  Containment Actions Summary")
    print(f"{'='*62}{Style.RESET_ALL}")
    print(f"  Ransomware Process:   Termination commands generated")
    print(f"  Host Isolation:       Network isolation rules generated")
    print(f"  Malicious Domains:    {len(MALICIOUS_DOMAINS)} domains sinkheld")
    print(f"  Malicious IPs:        {len(MALICIOUS_IPS)} IPs blocked")
    print(f"  Suricata Rules:       {len(suricata_rules)} drop rules generated")
    print(f"  File Recovery:        {recovery['files_recovered']} files recovered")
    print(f"  Evidence:             {evidence_path}")
    print(f"\n  Next steps: Review respond/playbook.md for full IR procedure")


if __name__ == "__main__":
    main()
