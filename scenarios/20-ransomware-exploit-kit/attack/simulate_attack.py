#!/usr/bin/env python3
"""
Scenario 20: Ransomware via Exploit Kit Attack Simulation.

COMBO scenario combining Scenario 12 (Watering Hole) + Scenario 8 (Ransomware).

Full attack chain:
  Phase 1 - User visits compromised watering hole site
  Phase 2 - Exploit kit delivers ransomware payload
  Phase 3 - Ransomware encrypts files in /tmp/wcace-sandbox/
  Phase 4 - C2 communication for encryption key exchange

SAFETY: All file operations are restricted to /tmp/wcace-sandbox/ only.
"""

import json
import os
import random
import shutil
import sys
import time
from datetime import datetime

from colorama import Fore, Style, init

# Add project root to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))

from wcace_lib.log_generator import LogGenerator
from wcace_lib.siem_client import SIEMClient
from wcace_lib.constants import (
    ATTACKER_IP, ATTACKER_IPS, C2_SERVER_IP, C2_DOMAIN,
    COMPANY_DOMAIN, REGULAR_USERS, WORKSTATION_IPS,
    WEB_SERVER_IP, WATERING_HOLE_DOMAIN, MITRE,
)

init(autoreset=True)

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

SANDBOX_ROOT = "/tmp/wcace-sandbox"
SANDBOX_DIR = os.path.join(SANDBOX_ROOT, "ransomware-ek-files")
LOG_DIR = os.path.join(os.path.dirname(__file__), "..", "logs", "sample_logs")

# Watering hole infrastructure
EXPLOIT_KIT_DOMAIN = "cdn-assets.newsportal.test"
EXPLOIT_KIT_IP = ATTACKER_IPS[3]

# Victim details
VICTIM_USER = random.choice(REGULAR_USERS)
VICTIM_IP = random.choice(WORKSTATION_IPS)

BROWSER_UA = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/92.0.4515.107 Safari/537.36"
)

# Sample files that the "victim" would have
SAMPLE_FILES = {
    "financial_report_q3.xlsx": "Revenue: $14.2M, Expenses: $9.7M, Net Income: $4.5M",
    "employee_directory.csv": "Name,Email,Department\nJohn Doe,john@acme.com,Engineering",
    "strategic_plan_2026.docx": "Five-year strategic plan with acquisition targets and budgets.",
    "board_minutes.pdf": "Board meeting minutes - discussed merger with Target Corp.",
    "source_code/main.py": "#!/usr/bin/env python3\n# Critical application source code",
    "source_code/config.yaml": "database:\n  host: db-prod\n  password: Pr0d_Secr3t!",
    "legal/patent_filing.docx": "Patent application for proprietary algorithm.",
    "legal/contract_vendor.pdf": "Master services agreement - $5.2M annual value.",
    "backups/db_export.sql": "-- Production database export\nCREATE TABLE customers (...);",
    "presentations/investor_deck.pptx": "Q3 investor presentation with growth projections.",
}

RANSOM_NOTE = """
================================================================
           YOUR FILES HAVE BEEN ENCRYPTED!
================================================================

All your documents, databases, source code, and important files
have been encrypted with military-grade AES-256 encryption.

To recover your files, you must pay 3.0 BTC to:
  bc1q9h5yjqn3kfl4z6mn2r7c3p5s8xvwt2ke4uf9j7

After payment, send proof to:
  recovery-support@{c2_domain}

Your unique victim ID: {victim_id}
Encryption timestamp: {timestamp}
Files encrypted: {file_count}

WARNING: Do not attempt to:
  - Decrypt files yourself (you will corrupt them)
  - Rename encrypted files
  - Contact law enforcement
  - Use third-party decryption tools

You have 48 hours before the price doubles.
After 7 days, the decryption key will be permanently deleted.
================================================================

[SIMULATION NOTICE: This is a WCACE SOC training exercise.
 No real encryption or ransom is involved.]
"""


# ---------------------------------------------------------------------------
# Safety checks
# ---------------------------------------------------------------------------

def verify_sandbox(path: str) -> bool:
    """Verify that the given path is inside the sandbox directory."""
    real_path = os.path.realpath(path)
    sandbox_real = os.path.realpath(SANDBOX_ROOT)
    return real_path.startswith(sandbox_real)


def safety_check():
    """Perform pre-flight safety checks before running simulation."""
    if not SANDBOX_ROOT.startswith("/tmp/"):
        print(f"{Fore.RED}[SAFETY] Sandbox must be under /tmp/. Aborting.{Style.RESET_ALL}")
        sys.exit(1)

    if os.path.exists(SANDBOX_ROOT):
        real = os.path.realpath(SANDBOX_ROOT)
        if not real.startswith("/tmp/"):
            print(f"{Fore.RED}[SAFETY] Sandbox symlink escape detected. Aborting.{Style.RESET_ALL}")
            sys.exit(1)

    print(f"{Fore.GREEN}[SAFETY] All pre-flight checks passed. "
          f"Sandbox: {SANDBOX_ROOT}{Style.RESET_ALL}")


# ---------------------------------------------------------------------------
# Banner
# ---------------------------------------------------------------------------

def banner():
    print(f"""
{Fore.RED}+==============================================================+
|  WCACE Scenario 20: Ransomware via Exploit Kit               |
|  COMBO: Watering Hole (S12) + Ransomware (S08)              |
|  Sandbox: {SANDBOX_ROOT:<50s}|
|  WARNING: Educational use only                               |
+==============================================================+{Style.RESET_ALL}
""")


# ---------------------------------------------------------------------------
# Phase 1: Watering Hole Visit
# ---------------------------------------------------------------------------

def phase_1_watering_hole(log_gen: LogGenerator) -> list[str]:
    """Simulate user visiting a compromised watering hole site."""
    print(f"{Fore.YELLOW}[Phase 1] User Visits Compromised Watering Hole Site{Style.RESET_ALL}")
    logs = []

    print(f"  Victim: {VICTIM_USER}@{COMPANY_DOMAIN} ({VICTIM_IP})")
    print(f"  Watering hole: {WATERING_HOLE_DOMAIN}")
    print(f"  Exploit kit: {EXPLOIT_KIT_DOMAIN} ({EXPLOIT_KIT_IP})\n")

    # Normal browsing to the watering hole site
    legit_pages = [
        f"https://{WATERING_HOLE_DOMAIN}/",
        f"https://{WATERING_HOLE_DOMAIN}/industry-news",
        f"https://{WATERING_HOLE_DOMAIN}/article/market-trends-2026",
        f"https://{WATERING_HOLE_DOMAIN}/css/theme.css",
        f"https://{WATERING_HOLE_DOMAIN}/js/analytics.js",
    ]

    for url in legit_pages:
        logs.append(log_gen.web_access_log(
            VICTIM_IP, "GET", url, status=200, user_agent=BROWSER_UA,
        ))
        print(f"  [200] GET {url}")

    # The compromised page includes a malicious script tag
    malicious_script_url = f"https://{WATERING_HOLE_DOMAIN}/js/tracking.js"
    logs.append(log_gen.web_access_log(
        VICTIM_IP, "GET", malicious_script_url, status=200, user_agent=BROWSER_UA,
    ))
    print(f"\n  {Fore.RED}[INJECT]{Style.RESET_ALL} GET {malicious_script_url} (injected malicious script)")

    # Script redirects to exploit kit
    ek_redirect_url = f"https://{EXPLOIT_KIT_DOMAIN}/gate?ref={WATERING_HOLE_DOMAIN}&sid=a8f3e"
    logs.append(log_gen.web_access_log(
        VICTIM_IP, "GET", ek_redirect_url, status=302, user_agent=BROWSER_UA,
    ))
    print(f"  {Fore.RED}[REDIRECT]{Style.RESET_ALL} 302 -> {ek_redirect_url}")

    # DNS queries
    logs.append(log_gen.dns_query_log(
        VICTIM_IP, WATERING_HOLE_DOMAIN, query_type="A",
        response=f"A {WEB_SERVER_IP}",
    ))
    logs.append(log_gen.dns_query_log(
        VICTIM_IP, EXPLOIT_KIT_DOMAIN, query_type="A",
        response=f"A {EXPLOIT_KIT_IP}",
    ))

    # IDS alert for watering hole redirect
    logs.append(log_gen.ids_alert(
        WEB_SERVER_IP, VICTIM_IP,
        "Watering Hole: Suspicious redirect from compromised news site to exploit kit",
        sid=9200001, severity=1,
    ))

    # Wazuh alert
    logs.append(log_gen.json_log("wazuh_alert", {
        "rule_id": 100580,
        "rule_level": 11,
        "rule_description": "WCACE S20: Watering hole site accessed - redirect to exploit kit detected",
        "src_ip": VICTIM_IP,
        "watering_hole": WATERING_HOLE_DOMAIN,
        "exploit_kit": EXPLOIT_KIT_DOMAIN,
        "mitre": ["T1189"],
    }, severity="warning"))

    print(f"\n  {Fore.CYAN}[*] Victim browsed watering hole -- "
          f"redirected to exploit kit{Style.RESET_ALL}")

    return logs


# ---------------------------------------------------------------------------
# Phase 2: Exploit Kit Delivers Payload
# ---------------------------------------------------------------------------

def phase_2_exploit_kit(log_gen: LogGenerator) -> list[str]:
    """Simulate exploit kit probing and delivering ransomware payload."""
    print(f"\n{Fore.YELLOW}[Phase 2] Exploit Kit Delivers Ransomware Payload{Style.RESET_ALL}")
    logs = []

    # Exploit kit landing page
    landing_url = f"https://{EXPLOIT_KIT_DOMAIN}/landing?id=a8f3e"
    logs.append(log_gen.web_access_log(
        VICTIM_IP, "GET", landing_url, status=200, user_agent=BROWSER_UA,
    ))
    print(f"  [200] GET {landing_url}")

    # Browser probing
    probe_urls = [
        f"https://{EXPLOIT_KIT_DOMAIN}/probe?t=browser&v=Chrome/92",
        f"https://{EXPLOIT_KIT_DOMAIN}/probe?t=os&v=Win10",
        f"https://{EXPLOIT_KIT_DOMAIN}/probe?t=plugins&v=pdf,java",
    ]

    for url in probe_urls:
        logs.append(log_gen.web_access_log(
            VICTIM_IP, "GET", url, status=200, user_agent=BROWSER_UA,
        ))
        print(f"  [PROBE] GET {url}")

    # Exploit delivered
    exploit_url = f"https://{EXPLOIT_KIT_DOMAIN}/exploit?cve=CVE-2021-21224&t=v8"
    logs.append(log_gen.web_access_log(
        VICTIM_IP, "GET", exploit_url, status=200, user_agent=BROWSER_UA,
    ))
    print(f"\n  {Fore.RED}[EXPLOIT]{Style.RESET_ALL} Browser exploit triggered: CVE-2021-21224")

    # Payload download
    payload_url = f"https://{EXPLOIT_KIT_DOMAIN}/payload/svchost_patch.exe"
    logs.append(log_gen.web_access_log(
        VICTIM_IP, "GET", payload_url, status=200, user_agent=BROWSER_UA,
    ))
    print(f"  {Fore.RED}[DOWNLOAD]{Style.RESET_ALL} Ransomware payload: {payload_url}")

    # Log file creation
    payload_hash = "b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2" + "a" * 32
    logs.append(log_gen.json_log("file_creation", {
        "user": VICTIM_USER,
        "src_ip": VICTIM_IP,
        "file_path": "C:\\Users\\victim\\AppData\\Local\\Temp\\svchost_patch.exe",
        "file_size": random.randint(200000, 600000),
        "file_hash_sha256": payload_hash,
        "download_url": payload_url,
        "mitre_technique": MITRE["initial_access"]["drive_by"],
    }, severity="critical"))

    # Process execution
    logs.append(log_gen.json_log("process_execution", {
        "user": VICTIM_USER,
        "src_ip": VICTIM_IP,
        "process": "svchost_patch.exe",
        "parent_process": "chrome.exe",
        "command_line": "svchost_patch.exe /quiet",
        "pid": random.randint(4000, 9999),
        "mitre_technique": MITRE["execution"]["exploitation_client"],
    }, severity="critical"))
    print(f"  {Fore.RED}[EXEC]{Style.RESET_ALL} svchost_patch.exe launched by chrome.exe")

    # IDS alerts
    logs.append(log_gen.ids_alert(
        EXPLOIT_KIT_IP, VICTIM_IP,
        "Exploit Kit: Ransomware payload delivery via drive-by download",
        sid=9200002, severity=1,
    ))
    logs.append(log_gen.ids_alert(
        EXPLOIT_KIT_IP, VICTIM_IP,
        "Suspicious PE download from exploit kit infrastructure",
        sid=9200003, severity=1,
    ))

    # Wazuh alerts
    logs.append(log_gen.json_log("wazuh_alert", {
        "rule_id": 100582,
        "rule_level": 13,
        "rule_description": "WCACE S20: Exploit kit delivered ransomware payload via browser exploit",
        "src_ip": VICTIM_IP,
        "exploit_kit": EXPLOIT_KIT_DOMAIN,
        "payload_hash": payload_hash,
        "cve": "CVE-2021-21224",
        "mitre": ["T1189", "T1203"],
    }, severity="critical"))

    print(f"\n  {Fore.CYAN}[*] Ransomware payload delivered and executing{Style.RESET_ALL}")

    return logs


# ---------------------------------------------------------------------------
# Phase 3: Ransomware Encryption
# ---------------------------------------------------------------------------

def phase_3_ransomware(log_gen: LogGenerator) -> tuple[list[str], str, int]:
    """Encrypt files in the sandbox using Fernet symmetric encryption."""
    print(f"\n{Fore.YELLOW}[Phase 3] Ransomware Encrypts Files{Style.RESET_ALL}")
    logs = []

    try:
        from cryptography.fernet import Fernet
    except ImportError:
        print(f"  {Fore.RED}[!] cryptography package not installed. "
              f"Run: pip install cryptography{Style.RESET_ALL}")
        return logs, "", 0

    # Clean and create sandbox
    if os.path.exists(SANDBOX_DIR):
        shutil.rmtree(SANDBOX_DIR)
    os.makedirs(SANDBOX_DIR, exist_ok=True)

    # Create sample victim files
    print(f"  Creating victim files in {SANDBOX_DIR}...")
    for filename, content in SAMPLE_FILES.items():
        filepath = os.path.join(SANDBOX_DIR, filename)
        filedir = os.path.dirname(filepath)

        if not verify_sandbox(filedir):
            print(f"  {Fore.RED}[SAFETY] Skipping {filename} -- outside sandbox{Style.RESET_ALL}")
            continue

        os.makedirs(filedir, exist_ok=True)
        with open(filepath, "w") as f:
            f.write(content)

    # Generate encryption key
    key = Fernet.generate_key()
    fernet = Fernet(key)
    key_str = key.decode()

    print(f"  Encryption key: {key_str[:20]}...  (saved for recovery)")
    print(f"  Encrypting files...\n")

    encrypted_count = 0

    for root, dirs, files in os.walk(SANDBOX_DIR):
        # Safety: ensure we are still inside sandbox
        if not verify_sandbox(root):
            print(f"  {Fore.RED}[SAFETY] Skipping directory outside sandbox: {root}{Style.RESET_ALL}")
            continue

        for filename in files:
            if filename.endswith(".encrypted") or filename == "RANSOM_NOTE.txt":
                continue

            filepath = os.path.join(root, filename)

            if not verify_sandbox(filepath):
                print(f"  {Fore.RED}[SAFETY] Skipping file outside sandbox: {filepath}{Style.RESET_ALL}")
                continue

            try:
                with open(filepath, "rb") as f:
                    original_data = f.read()

                encrypted_data = fernet.encrypt(original_data)

                encrypted_path = filepath + ".encrypted"
                with open(encrypted_path, "wb") as f:
                    f.write(encrypted_data)

                os.remove(filepath)
                encrypted_count += 1

                rel_path = os.path.relpath(filepath, SANDBOX_DIR)
                print(f"    {Fore.RED}[ENCRYPTED]{Style.RESET_ALL} {rel_path} -> {rel_path}.encrypted")

                # FIM alert for each file
                logs.append(log_gen.json_log("fim_alert", {
                    "src_ip": VICTIM_IP,
                    "file_path": filepath,
                    "action": "deleted",
                    "alert_type": "syscheck",
                    "mitre_technique": MITRE["impact"]["data_encrypted"],
                }, severity="critical"))

                logs.append(log_gen.json_log("fim_alert", {
                    "src_ip": VICTIM_IP,
                    "file_path": encrypted_path,
                    "action": "created",
                    "file_size": len(encrypted_data),
                    "file_extension": ".encrypted",
                    "alert_type": "syscheck",
                    "mitre_technique": MITRE["impact"]["data_encrypted"],
                }, severity="critical"))

            except Exception as e:
                print(f"    [!] Error encrypting {filename}: {e}")

    # Drop ransom notes
    for root, dirs, files in os.walk(SANDBOX_DIR):
        if not verify_sandbox(root):
            continue

        note_path = os.path.join(root, "RANSOM_NOTE.txt")
        victim_id = f"WCACE-EK-{random.randint(100000, 999999)}"
        note_content = RANSOM_NOTE.format(
            c2_domain=C2_DOMAIN,
            victim_id=victim_id,
            timestamp=datetime.now().isoformat(),
            file_count=encrypted_count,
        )
        with open(note_path, "w") as f:
            f.write(note_content)

        logs.append(log_gen.json_log("fim_alert", {
            "src_ip": VICTIM_IP,
            "file_path": note_path,
            "action": "created",
            "file_name": "RANSOM_NOTE.txt",
            "alert_type": "syscheck",
            "mitre_technique": MITRE["impact"]["data_encrypted"],
        }, severity="critical"))

    # Wazuh alerts for ransomware activity
    logs.append(log_gen.json_log("wazuh_alert", {
        "rule_id": 100584,
        "rule_level": 14,
        "rule_description": "WCACE S20: Mass file modification detected - ransomware encryption in progress",
        "src_ip": VICTIM_IP,
        "files_affected": encrypted_count,
        "time_window_seconds": 15,
        "alert_type": "syscheck",
        "mitre": ["T1486"],
    }, severity="critical"))

    logs.append(log_gen.json_log("wazuh_alert", {
        "rule_id": 100585,
        "rule_level": 14,
        "rule_description": "WCACE S20: Ransomware file extension detected (.encrypted)",
        "src_ip": VICTIM_IP,
        "extension": ".encrypted",
        "count": encrypted_count,
        "mitre": ["T1486"],
    }, severity="critical"))

    logs.append(log_gen.json_log("wazuh_alert", {
        "rule_id": 100586,
        "rule_level": 15,
        "rule_description": "WCACE S20: Ransom note file created (RANSOM_NOTE.txt)",
        "src_ip": VICTIM_IP,
        "file_name": "RANSOM_NOTE.txt",
        "mitre": ["T1486"],
    }, severity="critical"))

    print(f"\n  {Fore.RED}[!] {encrypted_count} files encrypted{Style.RESET_ALL}")
    print(f"  {Fore.RED}[!] RANSOM_NOTE.txt dropped in affected directories{Style.RESET_ALL}")

    return logs, key_str, encrypted_count


# ---------------------------------------------------------------------------
# Phase 4: C2 Communication for Key Exchange
# ---------------------------------------------------------------------------

def phase_4_c2_key_exchange(log_gen: LogGenerator, encryption_key: str,
                             encrypted_count: int) -> list[str]:
    """Simulate C2 communication for encryption key exchange."""
    print(f"\n{Fore.YELLOW}[Phase 4] C2 Communication for Key Exchange{Style.RESET_ALL}")
    logs = []

    # DNS query for C2 domain
    logs.append(log_gen.dns_query_log(
        VICTIM_IP, C2_DOMAIN, query_type="A",
        response=f"A {C2_SERVER_IP}",
    ))
    print(f"  [DNS] Resolving {C2_DOMAIN} -> {C2_SERVER_IP}")

    # Key exchange -- send encryption key to C2
    logs.append(log_gen.web_access_log(
        VICTIM_IP, "POST",
        f"https://{C2_DOMAIN}/api/v1/key-exchange",
        status=200,
        user_agent="Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1)",
    ))
    print(f"  {Fore.RED}[C2]{Style.RESET_ALL} POST https://{C2_DOMAIN}/api/v1/key-exchange")

    logs.append(log_gen.json_log("c2_communication", {
        "src_ip": VICTIM_IP,
        "dst_ip": C2_SERVER_IP,
        "dst_port": 443,
        "protocol": "TLS",
        "action": "key_exchange",
        "bytes_sent": random.randint(500, 2000),
        "bytes_received": random.randint(100, 500),
        "mitre_technique": MITRE["command_and_control"]["encrypted"],
    }, severity="critical"))

    # Victim status report to C2
    logs.append(log_gen.web_access_log(
        VICTIM_IP, "POST",
        f"https://{C2_DOMAIN}/api/v1/status",
        status=200,
        user_agent="Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1)",
    ))
    print(f"  {Fore.RED}[C2]{Style.RESET_ALL} POST https://{C2_DOMAIN}/api/v1/status "
          f"(files: {encrypted_count})")

    logs.append(log_gen.json_log("c2_communication", {
        "src_ip": VICTIM_IP,
        "dst_ip": C2_SERVER_IP,
        "action": "status_report",
        "files_encrypted": encrypted_count,
        "victim_id": f"WCACE-EK-{random.randint(100000, 999999)}",
        "mitre_technique": MITRE["command_and_control"]["encrypted"],
    }, severity="critical"))

    # Periodic beacon
    for i in range(3):
        logs.append(log_gen.web_access_log(
            VICTIM_IP, "GET",
            f"https://{C2_DOMAIN}/api/v1/heartbeat?seq={i}",
            status=200,
            user_agent="Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1)",
        ))

    logs.append(log_gen.firewall_log(
        VICTIM_IP, C2_SERVER_IP,
        random.randint(49152, 65535), 443,
        action="allow", protocol="TCP",
    ))

    # IDS alerts
    logs.append(log_gen.ids_alert(
        VICTIM_IP, C2_SERVER_IP,
        "Ransomware C2: Encryption key exchange over TLS",
        sid=9200004, severity=1,
    ))
    logs.append(log_gen.ids_alert(
        VICTIM_IP, C2_SERVER_IP,
        "Ransomware C2: Periodic beacon to known malicious domain",
        sid=9200005, severity=1,
    ))

    # Wazuh alerts
    logs.append(log_gen.json_log("wazuh_alert", {
        "rule_id": 100587,
        "rule_level": 14,
        "rule_description": "WCACE S20: Ransomware C2 communication - encryption key exchange detected",
        "src_ip": VICTIM_IP,
        "dst_ip": C2_SERVER_IP,
        "c2_domain": C2_DOMAIN,
        "mitre": ["T1573"],
    }, severity="critical"))

    logs.append(log_gen.json_log("wazuh_alert", {
        "rule_id": 100588,
        "rule_level": 13,
        "rule_description": "WCACE S20: C2 beacon detected from ransomware-infected host",
        "src_ip": VICTIM_IP,
        "dst_ip": C2_SERVER_IP,
        "beacon_interval": "periodic",
        "mitre": ["T1573"],
    }, severity="critical"))

    # Correlation: full kill chain
    logs.append(log_gen.json_log("wazuh_alert", {
        "rule_id": 100589,
        "rule_level": 15,
        "rule_description": "WCACE S20: Ransomware-via-exploit-kit kill chain detected - watering hole to encryption",
        "src_ip": VICTIM_IP,
        "victim_user": VICTIM_USER,
        "kill_chain_phases": [
            "watering_hole_access",
            "exploit_kit_redirect",
            "ransomware_payload_delivery",
            "file_encryption",
            "ransom_note_dropped",
            "c2_key_exchange",
        ],
        "mitre": ["T1189", "T1203", "T1486", "T1573"],
        "related_scenarios": ["S12-watering-hole", "S08-ransomware"],
    }, severity="critical"))

    print(f"\n  {Fore.CYAN}[*] C2 key exchange complete -- "
          f"ransomware fully operational{Style.RESET_ALL}")

    return logs


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    banner()
    safety_check()

    log_gen = LogGenerator(source_host="victim-workstation")
    all_logs = []

    # Phase 1: Watering hole visit
    logs_p1 = phase_1_watering_hole(log_gen)
    all_logs.extend(logs_p1)
    time.sleep(0.5)

    # Phase 2: Exploit kit delivery
    logs_p2 = phase_2_exploit_kit(log_gen)
    all_logs.extend(logs_p2)
    time.sleep(0.5)

    # Phase 3: Ransomware encryption
    logs_p3, encryption_key, encrypted_count = phase_3_ransomware(log_gen)
    all_logs.extend(logs_p3)
    time.sleep(0.5)

    # Phase 4: C2 key exchange
    logs_p4 = phase_4_c2_key_exchange(log_gen, encryption_key, encrypted_count)
    all_logs.extend(logs_p4)

    # ---------------------------------------------------------------------------
    # Save logs
    # ---------------------------------------------------------------------------
    os.makedirs(LOG_DIR, exist_ok=True)

    # Save combined attack log
    log_file = os.path.join(LOG_DIR, "ransomware_ek_attack.jsonl")
    SIEMClient.write_logs_to_file(all_logs, log_file)

    # Save FIM alerts separately
    fim_logs = [l for l in all_logs if "fim_alert" in l or "wazuh_alert" in l]
    fim_file = os.path.join(LOG_DIR, "fim_alerts.jsonl")
    SIEMClient.write_logs_to_file(fim_logs, fim_file)

    # Save web proxy logs
    web_logs = [l for l in all_logs if '"event_type": "web_access"' in l]
    proxy_file = os.path.join(LOG_DIR, "proxy_logs.jsonl")
    SIEMClient.write_logs_to_file(web_logs, proxy_file)

    # Save encryption key for recovery exercises
    if encryption_key:
        key_file = os.path.join(LOG_DIR, "encryption_key.txt")
        with open(key_file, "w") as f:
            f.write(f"# WCACE Scenario 20 - Encryption Key for Recovery\n")
            f.write(f"# Generated: {datetime.now().isoformat()}\n")
            f.write(f"# Sandbox: {SANDBOX_DIR}\n")
            f.write(f"# Related: S12 (Watering Hole) + S08 (Ransomware)\n")
            f.write(f"key={encryption_key}\n")

    # ---------------------------------------------------------------------------
    # Summary
    # ---------------------------------------------------------------------------
    print(f"\n{Fore.GREEN}{'=' * 62}")
    print(f"  Attack Simulation Complete")
    print(f"{'=' * 62}{Style.RESET_ALL}")
    print(f"  Total log entries:      {len(all_logs)}")
    print(f"  Files encrypted:        {encrypted_count}")
    print(f"  Victim user:            {VICTIM_USER}")
    print(f"  Victim IP:              {VICTIM_IP}")
    print(f"  Watering hole:          {WATERING_HOLE_DOMAIN}")
    print(f"  Exploit kit:            {EXPLOIT_KIT_DOMAIN}")
    print(f"  C2 server:              {C2_DOMAIN} ({C2_SERVER_IP})")
    print(f"  Sandbox directory:      {SANDBOX_DIR}")
    print(f"\n  Log files:")
    print(f"    {log_file}")
    print(f"    {fim_file}")
    print(f"    {proxy_file}")
    if encryption_key:
        print(f"    {os.path.join(LOG_DIR, 'encryption_key.txt')}")

    # Try to push logs to Loki
    try:
        siem = SIEMClient()
        siem.loki_push_lines(
            {"job": "attack_sim", "scenario": "20-ransomware-exploit-kit"},
            all_logs,
        )
        print(f"\n  {Fore.GREEN}[*] Logs pushed to Loki{Style.RESET_ALL}")
    except Exception:
        print(f"\n  [*] Loki not available -- logs saved locally only")

    print(f"\n  Next: Run detect/verify_detection.py to verify alerts")
    print(f"        Run respond/containment.py for incident response\n")


if __name__ == "__main__":
    main()
