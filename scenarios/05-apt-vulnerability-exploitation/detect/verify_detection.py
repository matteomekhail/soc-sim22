#!/usr/bin/env python3
"""
Scenario 05: Verify APT Vulnerability Exploitation detection by SOC stack.

Checks local logs, Wazuh alerts, and Loki logs to confirm
the multi-stage APT attack was properly detected across all phases.
"""

import json
import os
import sys

from colorama import Fore, Style, init

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))

from wcace_lib.siem_client import SIEMClient

init(autoreset=True)

EXPECTED_FILE = os.path.join(os.path.dirname(__file__), "expected_alerts.json")
LOG_FILE = os.path.join(
    os.path.dirname(__file__), "..", "logs", "sample_logs", "apt_vulnerability_exploitation.jsonl"
)

# APT phase indicators to look for in logs
PHASE_INDICATORS = {
    "reconnaissance": {
        "patterns": ["Nmap", "Nikto", "port scan", "vulnerability scanner"],
        "event_types": ["firewall", "web_access", "ids_alert"],
    },
    "sql_injection": {
        "patterns": ["UNION SELECT", "OR 1=1", "SQL Injection", "information_schema"],
        "event_types": ["web_access", "ids_alert"],
    },
    "command_injection": {
        "patterns": ["Command Injection", "cmd=", ";id", ";whoami", ";uname"],
        "event_types": ["web_access", "ids_alert", "process_execution"],
    },
    "web_shell": {
        "patterns": ["shell.php", "webshell", "uploads/shell"],
        "event_types": ["web_access", "file_create", "process_execution"],
    },
    "tool_deployment": {
        "patterns": ["linpeas", "pspy", "mimikatz", "chisel", "nmap-static"],
        "event_types": ["data_transfer", "file_create", "process_execution"],
    },
    "privilege_escalation": {
        "patterns": ["pkexec", "pwnkit", "uid=0(root)", "www-data to root"],
        "event_types": ["process_execution"],
    },
    "lateral_movement": {
        "patterns": ["lateral movement", "DMZ server accessing internal"],
        "event_types": ["ids_alert", "process_execution"],
    },
}


def check_local_logs() -> dict:
    """Check locally generated attack logs for APT phase indicators."""
    results = {
        "total": 0,
        "phases_detected": {},
        "event_type_counts": {},
        "ids_alerts": 0,
        "critical_events": 0,
    }

    if not os.path.exists(LOG_FILE):
        print(f"{Fore.RED}[!] No attack logs found. Run simulate_attack.py first.{Style.RESET_ALL}")
        return results

    with open(LOG_FILE) as f:
        for line in f:
            if not line.strip():
                continue
            results["total"] += 1
            line_str = line.strip()

            try:
                entry = json.loads(line_str)
                event_type = entry.get("event_type", "unknown")
                severity = entry.get("severity", "info")

                # Count event types
                results["event_type_counts"][event_type] = \
                    results["event_type_counts"].get(event_type, 0) + 1

                if event_type == "ids_alert":
                    results["ids_alerts"] += 1
                if severity in ("critical", "alert"):
                    results["critical_events"] += 1

                # Check for phase indicators
                for phase, indicators in PHASE_INDICATORS.items():
                    for pattern in indicators["patterns"]:
                        if pattern.lower() in json.dumps(entry).lower():
                            if phase not in results["phases_detected"]:
                                results["phases_detected"][phase] = 0
                            results["phases_detected"][phase] += 1
                            break

            except json.JSONDecodeError:
                # Handle syslog-format entries
                for phase, indicators in PHASE_INDICATORS.items():
                    for pattern in indicators["patterns"]:
                        if pattern.lower() in line_str.lower():
                            if phase not in results["phases_detected"]:
                                results["phases_detected"][phase] = 0
                            results["phases_detected"][phase] += 1
                            break

    return results


def check_wazuh_alerts() -> list[dict]:
    """Query Wazuh for APT exploitation alerts."""
    try:
        from wcace_lib.wazuh_api import WazuhAPI
        api = WazuhAPI()
        if not api.check_connection():
            return []
        alerts = api.get_alerts(search="WCACE S05", limit=50)
        return alerts
    except Exception as e:
        print(f"  [*] Wazuh not available: {e}")
        return []


def check_loki_logs() -> int:
    """Query Loki for scenario 05 logs."""
    try:
        siem = SIEMClient()
        result = siem.loki_query('{scenario="05-apt-vuln-exploit"}', limit=100)
        streams = result.get("data", {}).get("result", [])
        count = sum(len(s.get("values", [])) for s in streams)
        return count
    except Exception:
        return 0


def main():
    print(f"""
{Fore.CYAN}{'='*62}
  WCACE Scenario 05: APT Vulnerability Exploitation
  Detection Verification
{'='*62}{Style.RESET_ALL}
""")

    # Load expected alerts
    with open(EXPECTED_FILE) as f:
        expected = json.load(f)

    total_checks = 0
    passed_checks = 0

    # Check 1: Local logs
    print(f"{Fore.YELLOW}[1/3] Checking local attack logs...{Style.RESET_ALL}")
    local = check_local_logs()
    if local["total"] > 0:
        print(f"  [+] {local['total']} log entries found")
        print(f"  [+] IDS alerts: {local['ids_alerts']}")
        print(f"  [+] Critical events: {local['critical_events']}")

        # Report event type breakdown
        print(f"\n  Event type breakdown:")
        for etype, count in sorted(local["event_type_counts"].items(), key=lambda x: -x[1]):
            print(f"    - {etype}: {count}")

        # Report phase detection
        print(f"\n  APT phases detected in logs:")
        all_phases = list(PHASE_INDICATORS.keys())
        detected_phases = 0
        for phase in all_phases:
            count = local["phases_detected"].get(phase, 0)
            if count > 0:
                status = f"{Fore.GREEN}DETECTED ({count} indicators){Style.RESET_ALL}"
                detected_phases += 1
            else:
                status = f"{Fore.RED}NOT DETECTED{Style.RESET_ALL}"
            print(f"    - {phase.replace('_', ' ').title()}: {status}")

        phase_coverage = detected_phases / len(all_phases) * 100
        print(f"\n  Phase detection coverage: {detected_phases}/{len(all_phases)} ({phase_coverage:.0f}%)")
        passed_checks += 1
    else:
        print(f"  {Fore.RED}[!] No logs found. Run simulate_attack.py first.{Style.RESET_ALL}")
    total_checks += 1

    # Check 2: Wazuh alerts
    print(f"\n{Fore.YELLOW}[2/3] Checking Wazuh alerts...{Style.RESET_ALL}")
    wazuh_alerts = check_wazuh_alerts()
    if wazuh_alerts:
        print(f"  [+] {len(wazuh_alerts)} Wazuh alerts found")
        for alert in wazuh_alerts[:5]:
            rule = alert.get("rule", {})
            print(f"    - Rule {rule.get('id')}: {rule.get('description', 'N/A')}")
        passed_checks += 1
    else:
        print(f"  [*] No Wazuh alerts (stack may not be running)")
    total_checks += 1

    # Check 3: Loki logs
    print(f"\n{Fore.YELLOW}[3/3] Checking Loki logs...{Style.RESET_ALL}")
    loki_count = check_loki_logs()
    if loki_count > 0:
        print(f"  [+] {loki_count} entries in Loki")
        passed_checks += 1
    else:
        print(f"  [*] No Loki entries (stack may not be running)")
    total_checks += 1

    # Summary
    print(f"\n{Fore.CYAN}{'='*62}")
    print(f"  Detection Verification Summary")
    print(f"{'='*62}{Style.RESET_ALL}")

    print(f"\n  Expected alerts for this scenario:")
    for ea in expected["expected_alerts"]:
        source = ea["source"].upper()
        desc = ea["description"]
        sev = ea["severity"].upper()
        rule_key = ea.get("rule_id") or ea.get("sid")
        print(f"    [{source}] {rule_key}: {desc} (severity: {sev})")

    print(f"\n{Fore.GREEN}  Detection checks: {passed_checks}/{total_checks} passed{Style.RESET_ALL}")
    print(f"  Next step: python3 respond/containment.py")


if __name__ == "__main__":
    main()
